{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem-vindos ao M\u00f3dulo de Compiladores! Introdu\u00e7\u00e3o Ol\u00e1, alunos! Sejam muito bem-vindos ao m\u00f3dulo de Compiladores. Este curso foi cuidadosamente elaborado para gui\u00e1-los atrav\u00e9s dos conceitos fundamentais e avan\u00e7ados da constru\u00e7\u00e3o de compiladores. Ao longo deste m\u00f3dulo, voc\u00eas aprender\u00e3o sobre as diferentes fases de um compilador, desde a an\u00e1lise l\u00e9xica at\u00e9 a gera\u00e7\u00e3o de c\u00f3digo. Objetivos do Curso Neste m\u00f3dulo, voc\u00eas ir\u00e3o: Compreender a estrutura e funcionamento de um compilador. Explorar as t\u00e9cnicas de an\u00e1lise l\u00e9xica, sint\u00e1tica e sem\u00e2ntica. Implementar componentes de um compilador utilizando a linguagem Python. Analisar e otimizar c\u00f3digo gerado. Desenvolver habilidades pr\u00e1ticas atrav\u00e9s de projetos e exerc\u00edcios. Recursos Adicionais Para auxili\u00e1-los no aprendizado, disponibilizamos os seguintes recursos: Material Did\u00e1tico: Apostilas, slides e artigos complementares. Exemplos de C\u00f3digo: Exemplos pr\u00e1ticos em Python para cada fase do compilador. F\u00f3rum de Discuss\u00e3o: Espa\u00e7o para tirar d\u00favidas e discutir t\u00f3picos com colegas e instrutores. Projetos: Projetos pr\u00e1ticos para aplicar os conceitos aprendidos. Contato Se tiverem qualquer d\u00favida ou precisarem de ajuda, n\u00e3o hesitem em entrar em contato com os instrutores: Professor Jo\u00e3o Silva: joao.silva@universidade.com Assistente Maria Oliveira: maria.oliveira@universidade.com Estamos aqui para ajudar e garantir que voc\u00eas tenham uma experi\u00eancia de aprendizado enriquecedora e produtiva. Conclus\u00e3o Estamos muito empolgados em iniciar esta jornada com voc\u00eas. Compiladores s\u00e3o uma parte fundamental da ci\u00eancia da computa\u00e7\u00e3o e esperamos que este curso inspire e capacite voc\u00eas a explorar ainda mais este fascinante campo. Vamos come\u00e7ar! Equipe do M\u00f3dulo de Compiladores","title":"Home"},{"location":"#bem-vindos-ao-modulo-de-compiladores","text":"","title":"Bem-vindos ao M\u00f3dulo de Compiladores!"},{"location":"#introducao","text":"Ol\u00e1, alunos! Sejam muito bem-vindos ao m\u00f3dulo de Compiladores. Este curso foi cuidadosamente elaborado para gui\u00e1-los atrav\u00e9s dos conceitos fundamentais e avan\u00e7ados da constru\u00e7\u00e3o de compiladores. Ao longo deste m\u00f3dulo, voc\u00eas aprender\u00e3o sobre as diferentes fases de um compilador, desde a an\u00e1lise l\u00e9xica at\u00e9 a gera\u00e7\u00e3o de c\u00f3digo.","title":"Introdu\u00e7\u00e3o"},{"location":"#objetivos-do-curso","text":"Neste m\u00f3dulo, voc\u00eas ir\u00e3o: Compreender a estrutura e funcionamento de um compilador. Explorar as t\u00e9cnicas de an\u00e1lise l\u00e9xica, sint\u00e1tica e sem\u00e2ntica. Implementar componentes de um compilador utilizando a linguagem Python. Analisar e otimizar c\u00f3digo gerado. Desenvolver habilidades pr\u00e1ticas atrav\u00e9s de projetos e exerc\u00edcios.","title":"Objetivos do Curso"},{"location":"#recursos-adicionais","text":"Para auxili\u00e1-los no aprendizado, disponibilizamos os seguintes recursos: Material Did\u00e1tico: Apostilas, slides e artigos complementares. Exemplos de C\u00f3digo: Exemplos pr\u00e1ticos em Python para cada fase do compilador. F\u00f3rum de Discuss\u00e3o: Espa\u00e7o para tirar d\u00favidas e discutir t\u00f3picos com colegas e instrutores. Projetos: Projetos pr\u00e1ticos para aplicar os conceitos aprendidos.","title":"Recursos Adicionais"},{"location":"#contato","text":"Se tiverem qualquer d\u00favida ou precisarem de ajuda, n\u00e3o hesitem em entrar em contato com os instrutores: Professor Jo\u00e3o Silva: joao.silva@universidade.com Assistente Maria Oliveira: maria.oliveira@universidade.com Estamos aqui para ajudar e garantir que voc\u00eas tenham uma experi\u00eancia de aprendizado enriquecedora e produtiva.","title":"Contato"},{"location":"#conclusao","text":"Estamos muito empolgados em iniciar esta jornada com voc\u00eas. Compiladores s\u00e3o uma parte fundamental da ci\u00eancia da computa\u00e7\u00e3o e esperamos que este curso inspire e capacite voc\u00eas a explorar ainda mais este fascinante campo. Vamos come\u00e7ar! Equipe do M\u00f3dulo de Compiladores","title":"Conclus\u00e3o"},{"location":"aula1/","text":"Aula 1 - Prazer, Compiladores! \ud83e\udd1d\ud83d\udc7e (Continua\u00e7\u00e3o) A Import\u00e2ncia dos Compiladores Na primeira parte da aula, vimos que os compiladores s\u00e3o como tradutores que transformam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o (que humanos entendem) para uma linguagem que o computador entende (linguagem de m\u00e1quina). Imagine que voc\u00ea quer ensinar um amigo a fazer um bolo, mas ele s\u00f3 fala japon\u00eas. Voc\u00ea precisaria de um tradutor para transmitir as instru\u00e7\u00f5es corretamente, certo? \u00c9 exatamente isso que um compilador faz! Ele garante que o computador compreenda e execute as instru\u00e7\u00f5es do seu programa. Fases da Compila\u00e7\u00e3o: Uma An\u00e1lise Detalhada Para um problema: A compila\u00e7\u00e3o, como vimos, \u00e9 um processo dividido em etapas. Vamos entender melhor as tr\u00eas principais: An\u00e1lise L\u00e9xica (Fase do \"dicion\u00e1rio\"): Nesta fase, o compilador age como um leitor que examina o c\u00f3digo letra por letra, agrupando-as em \"palavras\" com significado para a linguagem, como nomes de vari\u00e1veis, palavras-chave (ex.: if , else , for ) e operadores (+, -, *, /). Imagine um corretor ortogr\u00e1fico verificando cada palavra e sinal de pontua\u00e7\u00e3o do seu texto. An\u00e1lise L\u00e9xica e Express\u00f5es Regulares A An\u00e1lise L\u00e9xica \u00e9 a primeira fase de um compilador, respons\u00e1vel por dividir o c\u00f3digo-fonte em uma sequ\u00eancia de tokens. Esses tokens representam as unidades b\u00e1sicas da linguagem, como palavras-chave, identificadores, n\u00fameros, operadores, entre outros. Para realizar a An\u00e1lise L\u00e9xica, uma t\u00e9cnica comumente utilizada s\u00e3o as express\u00f5es regulares (regex). As express\u00f5es regulares s\u00e3o padr\u00f5es que descrevem um conjunto de cadeias de caracteres. Elas permitem identificar e extrair partes espec\u00edficas de um texto com base em regras definidas. As express\u00f5es regulares s\u00e3o compostas por caracteres literais e metacaracteres. Alguns metacaracteres comuns incluem: . (ponto): Corresponde a qualquer caractere, exceto uma nova linha. * (asterisco): Corresponde a zero ou mais ocorr\u00eancias do caractere ou grupo anterior. + (mais): Corresponde a uma ou mais ocorr\u00eancias do caractere ou grupo anterior. ? (interroga\u00e7\u00e3o): Corresponde a zero ou uma ocorr\u00eancia do caractere ou grupo anterior. ^ (circunflexo): Corresponde ao in\u00edcio da linha. $ (cifr\u00e3o): Corresponde ao final da linha. [] (colchetes): Define um conjunto de caracteres. Por exemplo, [aeiou] corresponde a qualquer vogal. Al\u00e9m disso, existem classes de caracteres predefinidas, como: \\d : Corresponde a qualquer d\u00edgito (0-9). \\w : Corresponde a qualquer caractere alfanum\u00e9rico (letra ou d\u00edgito). \\s : Corresponde a qualquer caractere de espa\u00e7o em branco (espa\u00e7o, tabula\u00e7\u00e3o, nova linha). Exemplo de express\u00e3o regular para identificar n\u00fameros inteiros: import re # Express\u00e3o regular para n\u00fameros inteiros pattern = r'\\d+' # Texto de exemplo text = \"Eu tenho 25 anos e meu irm\u00e3o tem 30 anos.\" # Encontrar todos os n\u00fameros inteiros no texto matches = re.findall(pattern, text) # Imprimir os n\u00fameros encontrados for match in matches: print(match) Nesse exemplo, a express\u00e3o regular \\d+ \u00e9 usada para encontrar n\u00fameros inteiros no texto. O m\u00e9todo re.findall() \u00e9 utilizado para encontrar todas as ocorr\u00eancias da express\u00e3o regular no texto. O resultado ser\u00e1: 25 30 As express\u00f5es regulares s\u00e3o uma ferramenta poderosa para a An\u00e1lise L\u00e9xica, permitindo identificar e extrair tokens espec\u00edficos do c\u00f3digo-fonte. Elas podem ser combinadas com outras t\u00e9cnicas, como aut\u00f4matos finitos, para construir um analisador l\u00e9xico completo. No entanto, \u00e9 importante ressaltar que as express\u00f5es regulares t\u00eam suas limita\u00e7\u00f5es. Elas s\u00e3o adequadas para identificar padr\u00f5es simples e regulares, mas podem se tornar complexas e dif\u00edceis de manter para linguagens com estruturas mais complexas. Nesses casos, outras t\u00e9cnicas, como a an\u00e1lise sint\u00e1tica, s\u00e3o necess\u00e1rias para lidar com a estrutura hier\u00e1rquica do c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica (Fase da \"gram\u00e1tica\"): Com as \"palavras\" identificadas, o compilador verifica se elas est\u00e3o organizadas de forma correta, seguindo as regras gramaticais da linguagem. \u00c9 como analisar se a ordem das palavras em uma frase faz sentido. Por exemplo, em portugu\u00eas, dizemos \"O gato comeu o peixe\", e n\u00e3o \"Comeu peixe o gato o\". An\u00e1lise Sint\u00e1tica A An\u00e1lise Sint\u00e1tica \u00e9 a segunda fase de um compilador, que ocorre ap\u00f3s a An\u00e1lise L\u00e9xica. Seu objetivo \u00e9 verificar se a sequ\u00eancia de tokens gerada pela An\u00e1lise L\u00e9xica est\u00e1 de acordo com as regras gramaticais da linguagem de programa\u00e7\u00e3o. Em outras palavras, a An\u00e1lise Sint\u00e1tica verifica se o c\u00f3digo-fonte possui uma estrutura v\u00e1lida. Durante a An\u00e1lise Sint\u00e1tica, o compilador constr\u00f3i uma representa\u00e7\u00e3o estruturada do c\u00f3digo-fonte, geralmente na forma de uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). A AST representa a estrutura hier\u00e1rquica do c\u00f3digo, mostrando a rela\u00e7\u00e3o entre os diferentes elementos da linguagem, como express\u00f5es, comandos e blocos de c\u00f3digo. Existem duas abordagens principais para a An\u00e1lise Sint\u00e1tica: An\u00e1lise Sint\u00e1tica Descendente (Top-Down Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir da regra gramatical mais geral e tenta derivar a sequ\u00eancia de tokens de entrada. O m\u00e9todo mais comum \u00e9 a an\u00e1lise preditiva recursiva, que utiliza recurs\u00e3o para percorrer a gram\u00e1tica e construir a AST. A an\u00e1lise descendente \u00e9 adequada para gram\u00e1ticas LL (Left-to-right, Leftmost derivation), onde \u00e9 poss\u00edvel escolher a regra correta a ser aplicada com base nos pr\u00f3ximos tokens de entrada. An\u00e1lise Sint\u00e1tica Ascendente (Bottom-Up Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir dos tokens de entrada e tenta reduzi-los \u00e0s regras gramaticais at\u00e9 chegar \u00e0 regra inicial. O m\u00e9todo mais comum \u00e9 o LR (Left-to-right, Rightmost derivation), que utiliza uma tabela de an\u00e1lise para determinar as a\u00e7\u00f5es a serem tomadas com base nos tokens de entrada. A an\u00e1lise ascendente \u00e9 adequada para gram\u00e1ticas mais complexas e amb\u00edguas, onde a escolha da regra correta depende dos tokens futuros. Exemplo de An\u00e1lise Sint\u00e1tica usando a abordagem descendente: def parse_expression(tokens): def parse_term(tokens): if tokens[0] == 'NUMBER': return ('NUMBER', tokens.pop(0)[1]) elif tokens[0] == 'LPAREN': tokens.pop(0) expr = parse_expression(tokens) if tokens.pop(0) != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") return expr def parse_factor(tokens): term = parse_term(tokens) while tokens and tokens[0] in ['MULTIPLY', 'DIVIDE']: op = tokens.pop(0) right = parse_term(tokens) term = (op, term, right) return term expr = parse_factor(tokens) while tokens and tokens[0] in ['PLUS', 'MINUS']: op = tokens.pop(0) right = parse_factor(tokens) expr = (op, expr, right) return expr Nesse exemplo, a fun\u00e7\u00e3o parse_expression realiza a an\u00e1lise sint\u00e1tica de uma express\u00e3o aritm\u00e9tica simples. Ela utiliza fun\u00e7\u00f5es auxiliares parse_term e parse_factor para lidar com os diferentes n\u00edveis de preced\u00eancia dos operadores. A an\u00e1lise \u00e9 feita de forma recursiva, consumindo os tokens de entrada e construindo a AST correspondente. A An\u00e1lise Sint\u00e1tica \u00e9 uma fase crucial do compilador, pois garante que o c\u00f3digo-fonte esteja estruturalmente correto antes de prosseguir para as pr\u00f3ximas etapas, como a An\u00e1lise Sem\u00e2ntica e a Gera\u00e7\u00e3o de C\u00f3digo. Ela tamb\u00e9m fornece informa\u00e7\u00f5es importantes sobre a estrutura do programa, que s\u00e3o usadas nas fases posteriores do processo de compila\u00e7\u00e3o. An\u00e1lise Sem\u00e2ntica (Fase da \"interpreta\u00e7\u00e3o\"): Ap\u00f3s a an\u00e1lise sint\u00e1tica, o compilador precisa entender o significado do c\u00f3digo. Ele verifica se as opera\u00e7\u00f5es fazem sentido, se as vari\u00e1veis foram declaradas corretamente e se os tipos de dados s\u00e3o compat\u00edveis. \u00c9 como analisar se as frases em um texto fazem sentido juntas e transmitem a mensagem desejada. Funcionamento de um Compilador Vamos rodar tudo isso em Python! Aqui est\u00e1 um exemplo de programa em Python que demonstra as tr\u00eas fases principais de um compilador: an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica e an\u00e1lise sem\u00e2ntica. import re # Defini\u00e7\u00e3o dos tokens tokens = [ (r'\\d+', 'NUMBER'), (r'\\+', 'PLUS'), (r'\\-', 'MINUS'), (r'\\*', 'MULTIPLY'), (r'\\/', 'DIVIDE'), (r'\\(', 'LPAREN'), (r'\\)', 'RPAREN'), (r'\\s+', 'WHITESPACE') ] # An\u00e1lise L\u00e9xica def lexical_analysis(code): lexemes = [] while code: matched = False for token_expr, token_type in tokens: match = re.match(token_expr, code) if match: value = match.group() if token_type != 'WHITESPACE': lexemes.append((token_type, value)) code = code[len(value):] matched = True break if not matched: raise ValueError(f\"Lexema inv\u00e1lido: {code}\") return lexemes # An\u00e1lise Sint\u00e1tica def syntax_analysis(lexemes): ast = [] while lexemes: token_type, value = lexemes.pop(0) if token_type == 'NUMBER': ast.append(('NUMBER', int(value))) elif token_type in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: ast.append((token_type,)) elif token_type == 'LPAREN': sub_expr = syntax_analysis(lexemes) ast.append(('EXPR', sub_expr)) if lexemes.pop(0)[0] != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") else: raise ValueError(f\"Token inesperado: {token_type}\") return ast # An\u00e1lise Sem\u00e2ntica def semantic_analysis(ast): if isinstance(ast, tuple): if ast[0] == 'NUMBER': return ast[1] elif ast[0] in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: return ast[0] elif ast[0] == 'EXPR': return semantic_analysis(ast[1]) elif isinstance(ast, list): if len(ast) != 3: raise ValueError(\"Express\u00e3o inv\u00e1lida\") left = semantic_analysis(ast[0]) op = semantic_analysis(ast[1]) right = semantic_analysis(ast[2]) if not isinstance(left, int) or not isinstance(right, int): raise ValueError(\"Operandos inv\u00e1lidos\") if op == 'PLUS': return left + right elif op == 'MINUS': return left - right elif op == 'MULTIPLY': return left * right elif op == 'DIVIDE': if right == 0: raise ValueError(\"Divis\u00e3o por zero\") return left // right # Exemplo de uso code = \"2 + (3 * 4) - 5\" print(\"C\u00f3digo fonte:\", code) lexemes = lexical_analysis(code) print(\"An\u00e1lise L\u00e9xica:\", lexemes) ast = syntax_analysis(lexemes) print(\"An\u00e1lise Sint\u00e1tica:\", ast) result = semantic_analysis(ast) print(\"An\u00e1lise Sem\u00e2ntica:\", result) Explica\u00e7\u00e3o do programa: An\u00e1lise L\u00e9xica: Definimos os tokens que o compilador reconhecer\u00e1, como n\u00fameros, operadores e par\u00eanteses. A fun\u00e7\u00e3o lexical_analysis recebe o c\u00f3digo-fonte como entrada e retorna uma lista de lexemas (tokens) encontrados no c\u00f3digo. Utilizamos express\u00f5es regulares para identificar os tokens no c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica: A fun\u00e7\u00e3o syntax_analysis recebe a lista de lexemas como entrada e constr\u00f3i uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). Percorremos os lexemas e constru\u00edmos a AST com base na estrutura da express\u00e3o. Tratamos par\u00eanteses aninhados recursivamente. An\u00e1lise Sem\u00e2ntica: A fun\u00e7\u00e3o semantic_analysis recebe a AST como entrada e realiza a an\u00e1lise sem\u00e2ntica. Percorremos a AST recursivamente e avaliamos a express\u00e3o de acordo com as regras sem\u00e2nticas. Verificamos se os operandos s\u00e3o v\u00e1lidos e realizamos as opera\u00e7\u00f5es aritm\u00e9ticas correspondentes. No exemplo de uso, fornecemos um c\u00f3digo-fonte simples \"2 + (3 * 4) - 5\" e aplicamos as tr\u00eas fases do compilador: 1. An\u00e1lise L\u00e9xica: Obtemos a lista de lexemas. 2. An\u00e1lise Sint\u00e1tica: Constru\u00edmos a AST a partir dos lexemas. 3. An\u00e1lise Sem\u00e2ntica: Avaliamos a express\u00e3o e obtemos o resultado final. Esse programa \u00e9 uma simplifica\u00e7\u00e3o das fases de um compilador e serve para ilustrar os conceitos b\u00e1sicos envolvidos em cada fase. Em um compilador real, essas fases s\u00e3o mais complexas e envolvem mais etapas e detalhes. A Tabela de S\u00edmbolos: Organizando a Informa\u00e7\u00e3o A tabela de s\u00edmbolos \u00e9 como um dicion\u00e1rio que o compilador utiliza para armazenar e organizar informa\u00e7\u00f5es sobre todos os elementos do seu c\u00f3digo, como vari\u00e1veis, fun\u00e7\u00f5es e classes. Imagine que voc\u00ea est\u00e1 organizando uma festa e precisa controlar uma lista de convidados. Para cada convidado, voc\u00ea anota seu nome, n\u00famero de telefone e se ele confirmou presen\u00e7a. A tabela de s\u00edmbolos funciona de maneira similar, guardando informa\u00e7\u00f5es importantes sobre cada elemento do seu c\u00f3digo. Atividade em Sala de Aula Objetivo: Compreender a import\u00e2ncia da tabela de s\u00edmbolos na an\u00e1lise de c\u00f3digo. Enunciado: Imagine que voc\u00ea \u00e9 um compilador e precisa analisar o c\u00f3digo abaixo. Crie uma tabela de s\u00edmbolos listando todos os elementos (vari\u00e1veis, constantes, etc.) e seus respectivos atributos (tipo, escopo, etc.). nome = \"Maria\" idade = 25 PI = 3.1415 if idade >= 18: print(nome, \"\u00e9 maior de idade.\") else: print(nome, \"\u00e9 menor de idade.\") Dica: Utilize o seguinte formato para a tabela: Elemento Tipo Escopo Valor nome idade PI Observa\u00e7\u00e3o: Discuta com seus colegas as diferen\u00e7as entre vari\u00e1veis e constantes, e a import\u00e2ncia de definir o tipo de dado para cada elemento.","title":"Aula 1"},{"location":"aula1/#aula-1-prazer-compiladores-continuacao","text":"","title":"Aula 1 - Prazer, Compiladores! \ud83e\udd1d\ud83d\udc7e (Continua\u00e7\u00e3o)"},{"location":"aula1/#a-importancia-dos-compiladores","text":"Na primeira parte da aula, vimos que os compiladores s\u00e3o como tradutores que transformam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o (que humanos entendem) para uma linguagem que o computador entende (linguagem de m\u00e1quina). Imagine que voc\u00ea quer ensinar um amigo a fazer um bolo, mas ele s\u00f3 fala japon\u00eas. Voc\u00ea precisaria de um tradutor para transmitir as instru\u00e7\u00f5es corretamente, certo? \u00c9 exatamente isso que um compilador faz! Ele garante que o computador compreenda e execute as instru\u00e7\u00f5es do seu programa.","title":"A Import\u00e2ncia dos Compiladores"},{"location":"aula1/#fases-da-compilacao-uma-analise-detalhada","text":"","title":"Fases da Compila\u00e7\u00e3o: Uma An\u00e1lise Detalhada"},{"location":"aula1/#para-um-problema","text":"A compila\u00e7\u00e3o, como vimos, \u00e9 um processo dividido em etapas. Vamos entender melhor as tr\u00eas principais: An\u00e1lise L\u00e9xica (Fase do \"dicion\u00e1rio\"): Nesta fase, o compilador age como um leitor que examina o c\u00f3digo letra por letra, agrupando-as em \"palavras\" com significado para a linguagem, como nomes de vari\u00e1veis, palavras-chave (ex.: if , else , for ) e operadores (+, -, *, /). Imagine um corretor ortogr\u00e1fico verificando cada palavra e sinal de pontua\u00e7\u00e3o do seu texto.","title":"Para um problema:"},{"location":"aula1/#analise-lexica-e-expressoes-regulares","text":"A An\u00e1lise L\u00e9xica \u00e9 a primeira fase de um compilador, respons\u00e1vel por dividir o c\u00f3digo-fonte em uma sequ\u00eancia de tokens. Esses tokens representam as unidades b\u00e1sicas da linguagem, como palavras-chave, identificadores, n\u00fameros, operadores, entre outros. Para realizar a An\u00e1lise L\u00e9xica, uma t\u00e9cnica comumente utilizada s\u00e3o as express\u00f5es regulares (regex). As express\u00f5es regulares s\u00e3o padr\u00f5es que descrevem um conjunto de cadeias de caracteres. Elas permitem identificar e extrair partes espec\u00edficas de um texto com base em regras definidas. As express\u00f5es regulares s\u00e3o compostas por caracteres literais e metacaracteres. Alguns metacaracteres comuns incluem: . (ponto): Corresponde a qualquer caractere, exceto uma nova linha. * (asterisco): Corresponde a zero ou mais ocorr\u00eancias do caractere ou grupo anterior. + (mais): Corresponde a uma ou mais ocorr\u00eancias do caractere ou grupo anterior. ? (interroga\u00e7\u00e3o): Corresponde a zero ou uma ocorr\u00eancia do caractere ou grupo anterior. ^ (circunflexo): Corresponde ao in\u00edcio da linha. $ (cifr\u00e3o): Corresponde ao final da linha. [] (colchetes): Define um conjunto de caracteres. Por exemplo, [aeiou] corresponde a qualquer vogal. Al\u00e9m disso, existem classes de caracteres predefinidas, como: \\d : Corresponde a qualquer d\u00edgito (0-9). \\w : Corresponde a qualquer caractere alfanum\u00e9rico (letra ou d\u00edgito). \\s : Corresponde a qualquer caractere de espa\u00e7o em branco (espa\u00e7o, tabula\u00e7\u00e3o, nova linha). Exemplo de express\u00e3o regular para identificar n\u00fameros inteiros: import re # Express\u00e3o regular para n\u00fameros inteiros pattern = r'\\d+' # Texto de exemplo text = \"Eu tenho 25 anos e meu irm\u00e3o tem 30 anos.\" # Encontrar todos os n\u00fameros inteiros no texto matches = re.findall(pattern, text) # Imprimir os n\u00fameros encontrados for match in matches: print(match) Nesse exemplo, a express\u00e3o regular \\d+ \u00e9 usada para encontrar n\u00fameros inteiros no texto. O m\u00e9todo re.findall() \u00e9 utilizado para encontrar todas as ocorr\u00eancias da express\u00e3o regular no texto. O resultado ser\u00e1: 25 30 As express\u00f5es regulares s\u00e3o uma ferramenta poderosa para a An\u00e1lise L\u00e9xica, permitindo identificar e extrair tokens espec\u00edficos do c\u00f3digo-fonte. Elas podem ser combinadas com outras t\u00e9cnicas, como aut\u00f4matos finitos, para construir um analisador l\u00e9xico completo. No entanto, \u00e9 importante ressaltar que as express\u00f5es regulares t\u00eam suas limita\u00e7\u00f5es. Elas s\u00e3o adequadas para identificar padr\u00f5es simples e regulares, mas podem se tornar complexas e dif\u00edceis de manter para linguagens com estruturas mais complexas. Nesses casos, outras t\u00e9cnicas, como a an\u00e1lise sint\u00e1tica, s\u00e3o necess\u00e1rias para lidar com a estrutura hier\u00e1rquica do c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica (Fase da \"gram\u00e1tica\"): Com as \"palavras\" identificadas, o compilador verifica se elas est\u00e3o organizadas de forma correta, seguindo as regras gramaticais da linguagem. \u00c9 como analisar se a ordem das palavras em uma frase faz sentido. Por exemplo, em portugu\u00eas, dizemos \"O gato comeu o peixe\", e n\u00e3o \"Comeu peixe o gato o\".","title":"An\u00e1lise L\u00e9xica e Express\u00f5es Regulares"},{"location":"aula1/#analise-sintatica","text":"A An\u00e1lise Sint\u00e1tica \u00e9 a segunda fase de um compilador, que ocorre ap\u00f3s a An\u00e1lise L\u00e9xica. Seu objetivo \u00e9 verificar se a sequ\u00eancia de tokens gerada pela An\u00e1lise L\u00e9xica est\u00e1 de acordo com as regras gramaticais da linguagem de programa\u00e7\u00e3o. Em outras palavras, a An\u00e1lise Sint\u00e1tica verifica se o c\u00f3digo-fonte possui uma estrutura v\u00e1lida. Durante a An\u00e1lise Sint\u00e1tica, o compilador constr\u00f3i uma representa\u00e7\u00e3o estruturada do c\u00f3digo-fonte, geralmente na forma de uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). A AST representa a estrutura hier\u00e1rquica do c\u00f3digo, mostrando a rela\u00e7\u00e3o entre os diferentes elementos da linguagem, como express\u00f5es, comandos e blocos de c\u00f3digo. Existem duas abordagens principais para a An\u00e1lise Sint\u00e1tica: An\u00e1lise Sint\u00e1tica Descendente (Top-Down Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir da regra gramatical mais geral e tenta derivar a sequ\u00eancia de tokens de entrada. O m\u00e9todo mais comum \u00e9 a an\u00e1lise preditiva recursiva, que utiliza recurs\u00e3o para percorrer a gram\u00e1tica e construir a AST. A an\u00e1lise descendente \u00e9 adequada para gram\u00e1ticas LL (Left-to-right, Leftmost derivation), onde \u00e9 poss\u00edvel escolher a regra correta a ser aplicada com base nos pr\u00f3ximos tokens de entrada. An\u00e1lise Sint\u00e1tica Ascendente (Bottom-Up Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir dos tokens de entrada e tenta reduzi-los \u00e0s regras gramaticais at\u00e9 chegar \u00e0 regra inicial. O m\u00e9todo mais comum \u00e9 o LR (Left-to-right, Rightmost derivation), que utiliza uma tabela de an\u00e1lise para determinar as a\u00e7\u00f5es a serem tomadas com base nos tokens de entrada. A an\u00e1lise ascendente \u00e9 adequada para gram\u00e1ticas mais complexas e amb\u00edguas, onde a escolha da regra correta depende dos tokens futuros. Exemplo de An\u00e1lise Sint\u00e1tica usando a abordagem descendente: def parse_expression(tokens): def parse_term(tokens): if tokens[0] == 'NUMBER': return ('NUMBER', tokens.pop(0)[1]) elif tokens[0] == 'LPAREN': tokens.pop(0) expr = parse_expression(tokens) if tokens.pop(0) != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") return expr def parse_factor(tokens): term = parse_term(tokens) while tokens and tokens[0] in ['MULTIPLY', 'DIVIDE']: op = tokens.pop(0) right = parse_term(tokens) term = (op, term, right) return term expr = parse_factor(tokens) while tokens and tokens[0] in ['PLUS', 'MINUS']: op = tokens.pop(0) right = parse_factor(tokens) expr = (op, expr, right) return expr Nesse exemplo, a fun\u00e7\u00e3o parse_expression realiza a an\u00e1lise sint\u00e1tica de uma express\u00e3o aritm\u00e9tica simples. Ela utiliza fun\u00e7\u00f5es auxiliares parse_term e parse_factor para lidar com os diferentes n\u00edveis de preced\u00eancia dos operadores. A an\u00e1lise \u00e9 feita de forma recursiva, consumindo os tokens de entrada e construindo a AST correspondente. A An\u00e1lise Sint\u00e1tica \u00e9 uma fase crucial do compilador, pois garante que o c\u00f3digo-fonte esteja estruturalmente correto antes de prosseguir para as pr\u00f3ximas etapas, como a An\u00e1lise Sem\u00e2ntica e a Gera\u00e7\u00e3o de C\u00f3digo. Ela tamb\u00e9m fornece informa\u00e7\u00f5es importantes sobre a estrutura do programa, que s\u00e3o usadas nas fases posteriores do processo de compila\u00e7\u00e3o. An\u00e1lise Sem\u00e2ntica (Fase da \"interpreta\u00e7\u00e3o\"): Ap\u00f3s a an\u00e1lise sint\u00e1tica, o compilador precisa entender o significado do c\u00f3digo. Ele verifica se as opera\u00e7\u00f5es fazem sentido, se as vari\u00e1veis foram declaradas corretamente e se os tipos de dados s\u00e3o compat\u00edveis. \u00c9 como analisar se as frases em um texto fazem sentido juntas e transmitem a mensagem desejada.","title":"An\u00e1lise Sint\u00e1tica"},{"location":"aula1/#funcionamento-de-um-compilador","text":"","title":"Funcionamento de um Compilador"},{"location":"aula1/#vamos-rodar-tudo-isso-em-python","text":"Aqui est\u00e1 um exemplo de programa em Python que demonstra as tr\u00eas fases principais de um compilador: an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica e an\u00e1lise sem\u00e2ntica. import re # Defini\u00e7\u00e3o dos tokens tokens = [ (r'\\d+', 'NUMBER'), (r'\\+', 'PLUS'), (r'\\-', 'MINUS'), (r'\\*', 'MULTIPLY'), (r'\\/', 'DIVIDE'), (r'\\(', 'LPAREN'), (r'\\)', 'RPAREN'), (r'\\s+', 'WHITESPACE') ] # An\u00e1lise L\u00e9xica def lexical_analysis(code): lexemes = [] while code: matched = False for token_expr, token_type in tokens: match = re.match(token_expr, code) if match: value = match.group() if token_type != 'WHITESPACE': lexemes.append((token_type, value)) code = code[len(value):] matched = True break if not matched: raise ValueError(f\"Lexema inv\u00e1lido: {code}\") return lexemes # An\u00e1lise Sint\u00e1tica def syntax_analysis(lexemes): ast = [] while lexemes: token_type, value = lexemes.pop(0) if token_type == 'NUMBER': ast.append(('NUMBER', int(value))) elif token_type in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: ast.append((token_type,)) elif token_type == 'LPAREN': sub_expr = syntax_analysis(lexemes) ast.append(('EXPR', sub_expr)) if lexemes.pop(0)[0] != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") else: raise ValueError(f\"Token inesperado: {token_type}\") return ast # An\u00e1lise Sem\u00e2ntica def semantic_analysis(ast): if isinstance(ast, tuple): if ast[0] == 'NUMBER': return ast[1] elif ast[0] in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: return ast[0] elif ast[0] == 'EXPR': return semantic_analysis(ast[1]) elif isinstance(ast, list): if len(ast) != 3: raise ValueError(\"Express\u00e3o inv\u00e1lida\") left = semantic_analysis(ast[0]) op = semantic_analysis(ast[1]) right = semantic_analysis(ast[2]) if not isinstance(left, int) or not isinstance(right, int): raise ValueError(\"Operandos inv\u00e1lidos\") if op == 'PLUS': return left + right elif op == 'MINUS': return left - right elif op == 'MULTIPLY': return left * right elif op == 'DIVIDE': if right == 0: raise ValueError(\"Divis\u00e3o por zero\") return left // right # Exemplo de uso code = \"2 + (3 * 4) - 5\" print(\"C\u00f3digo fonte:\", code) lexemes = lexical_analysis(code) print(\"An\u00e1lise L\u00e9xica:\", lexemes) ast = syntax_analysis(lexemes) print(\"An\u00e1lise Sint\u00e1tica:\", ast) result = semantic_analysis(ast) print(\"An\u00e1lise Sem\u00e2ntica:\", result) Explica\u00e7\u00e3o do programa: An\u00e1lise L\u00e9xica: Definimos os tokens que o compilador reconhecer\u00e1, como n\u00fameros, operadores e par\u00eanteses. A fun\u00e7\u00e3o lexical_analysis recebe o c\u00f3digo-fonte como entrada e retorna uma lista de lexemas (tokens) encontrados no c\u00f3digo. Utilizamos express\u00f5es regulares para identificar os tokens no c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica: A fun\u00e7\u00e3o syntax_analysis recebe a lista de lexemas como entrada e constr\u00f3i uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). Percorremos os lexemas e constru\u00edmos a AST com base na estrutura da express\u00e3o. Tratamos par\u00eanteses aninhados recursivamente. An\u00e1lise Sem\u00e2ntica: A fun\u00e7\u00e3o semantic_analysis recebe a AST como entrada e realiza a an\u00e1lise sem\u00e2ntica. Percorremos a AST recursivamente e avaliamos a express\u00e3o de acordo com as regras sem\u00e2nticas. Verificamos se os operandos s\u00e3o v\u00e1lidos e realizamos as opera\u00e7\u00f5es aritm\u00e9ticas correspondentes. No exemplo de uso, fornecemos um c\u00f3digo-fonte simples \"2 + (3 * 4) - 5\" e aplicamos as tr\u00eas fases do compilador: 1. An\u00e1lise L\u00e9xica: Obtemos a lista de lexemas. 2. An\u00e1lise Sint\u00e1tica: Constru\u00edmos a AST a partir dos lexemas. 3. An\u00e1lise Sem\u00e2ntica: Avaliamos a express\u00e3o e obtemos o resultado final. Esse programa \u00e9 uma simplifica\u00e7\u00e3o das fases de um compilador e serve para ilustrar os conceitos b\u00e1sicos envolvidos em cada fase. Em um compilador real, essas fases s\u00e3o mais complexas e envolvem mais etapas e detalhes.","title":"Vamos rodar tudo isso em Python!"},{"location":"aula1/#a-tabela-de-simbolos-organizando-a-informacao","text":"A tabela de s\u00edmbolos \u00e9 como um dicion\u00e1rio que o compilador utiliza para armazenar e organizar informa\u00e7\u00f5es sobre todos os elementos do seu c\u00f3digo, como vari\u00e1veis, fun\u00e7\u00f5es e classes. Imagine que voc\u00ea est\u00e1 organizando uma festa e precisa controlar uma lista de convidados. Para cada convidado, voc\u00ea anota seu nome, n\u00famero de telefone e se ele confirmou presen\u00e7a. A tabela de s\u00edmbolos funciona de maneira similar, guardando informa\u00e7\u00f5es importantes sobre cada elemento do seu c\u00f3digo.","title":"A Tabela de S\u00edmbolos: Organizando a Informa\u00e7\u00e3o"},{"location":"aula1/#atividade-em-sala-de-aula","text":"Objetivo: Compreender a import\u00e2ncia da tabela de s\u00edmbolos na an\u00e1lise de c\u00f3digo. Enunciado: Imagine que voc\u00ea \u00e9 um compilador e precisa analisar o c\u00f3digo abaixo. Crie uma tabela de s\u00edmbolos listando todos os elementos (vari\u00e1veis, constantes, etc.) e seus respectivos atributos (tipo, escopo, etc.). nome = \"Maria\" idade = 25 PI = 3.1415 if idade >= 18: print(nome, \"\u00e9 maior de idade.\") else: print(nome, \"\u00e9 menor de idade.\") Dica: Utilize o seguinte formato para a tabela: Elemento Tipo Escopo Valor nome idade PI Observa\u00e7\u00e3o: Discuta com seus colegas as diferen\u00e7as entre vari\u00e1veis e constantes, e a import\u00e2ncia de definir o tipo de dado para cada elemento.","title":"Atividade em Sala de Aula"},{"location":"aula2/","text":"Aula 2","title":"Aula 2"},{"location":"aula2/#aula-2","text":"","title":"Aula 2"},{"location":"aula3/","text":"Aula 3","title":"Aula 3"},{"location":"aula3/#aula-3","text":"","title":"Aula 3"},{"location":"aula4/","text":"Aula 4","title":"Aula 4"},{"location":"aula4/#aula-4","text":"","title":"Aula 4"}]}