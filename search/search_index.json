{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem-vindos ao M\u00f3dulo de Compiladores! Introdu\u00e7\u00e3o Ol\u00e1, alunos! Sejam muito bem-vindos ao m\u00f3dulo de Compiladores. Este curso foi cuidadosamente elaborado para gui\u00e1-los atrav\u00e9s dos conceitos fundamentais e avan\u00e7ados da constru\u00e7\u00e3o de compiladores. Ao longo deste m\u00f3dulo, voc\u00eas aprender\u00e3o sobre as diferentes fases de um compilador, desde a an\u00e1lise l\u00e9xica at\u00e9 a gera\u00e7\u00e3o de c\u00f3digo. Objetivos do Curso Neste m\u00f3dulo, voc\u00eas ir\u00e3o: Compreender a estrutura e funcionamento de um compilador. Explorar as t\u00e9cnicas de an\u00e1lise l\u00e9xica, sint\u00e1tica e sem\u00e2ntica. Implementar componentes de um compilador utilizando a linguagem Python. Analisar e otimizar c\u00f3digo gerado. Desenvolver habilidades pr\u00e1ticas atrav\u00e9s de projetos e exerc\u00edcios. Recursos Adicionais Para auxili\u00e1-los no aprendizado, disponibilizamos os seguintes recursos: Material Did\u00e1tico: Apostilas, slides e artigos complementares. Exemplos de C\u00f3digo: Exemplos pr\u00e1ticos em Python para cada fase do compilador. F\u00f3rum de Discuss\u00e3o: Espa\u00e7o para tirar d\u00favidas e discutir t\u00f3picos com colegas e instrutores. Projetos: Projetos pr\u00e1ticos para aplicar os conceitos aprendidos. Contato Se tiverem qualquer d\u00favida ou precisarem de ajuda, n\u00e3o hesitem em entrar em contato com os instrutores: Professor Jo\u00e3o Silva: joao.silva@universidade.com Assistente Maria Oliveira: maria.oliveira@universidade.com Estamos aqui para ajudar e garantir que voc\u00eas tenham uma experi\u00eancia de aprendizado enriquecedora e produtiva. Conclus\u00e3o Estamos muito empolgados em iniciar esta jornada com voc\u00eas. Compiladores s\u00e3o uma parte fundamental da ci\u00eancia da computa\u00e7\u00e3o e esperamos que este curso inspire e capacite voc\u00eas a explorar ainda mais este fascinante campo. Vamos come\u00e7ar! Equipe do M\u00f3dulo de Compiladores Quem ajusta o c\u00f3digo??? Link do formul\u00e1rio: Form","title":"Home"},{"location":"#bem-vindos-ao-modulo-de-compiladores","text":"","title":"Bem-vindos ao M\u00f3dulo de Compiladores!"},{"location":"#introducao","text":"Ol\u00e1, alunos! Sejam muito bem-vindos ao m\u00f3dulo de Compiladores. Este curso foi cuidadosamente elaborado para gui\u00e1-los atrav\u00e9s dos conceitos fundamentais e avan\u00e7ados da constru\u00e7\u00e3o de compiladores. Ao longo deste m\u00f3dulo, voc\u00eas aprender\u00e3o sobre as diferentes fases de um compilador, desde a an\u00e1lise l\u00e9xica at\u00e9 a gera\u00e7\u00e3o de c\u00f3digo.","title":"Introdu\u00e7\u00e3o"},{"location":"#objetivos-do-curso","text":"Neste m\u00f3dulo, voc\u00eas ir\u00e3o: Compreender a estrutura e funcionamento de um compilador. Explorar as t\u00e9cnicas de an\u00e1lise l\u00e9xica, sint\u00e1tica e sem\u00e2ntica. Implementar componentes de um compilador utilizando a linguagem Python. Analisar e otimizar c\u00f3digo gerado. Desenvolver habilidades pr\u00e1ticas atrav\u00e9s de projetos e exerc\u00edcios.","title":"Objetivos do Curso"},{"location":"#recursos-adicionais","text":"Para auxili\u00e1-los no aprendizado, disponibilizamos os seguintes recursos: Material Did\u00e1tico: Apostilas, slides e artigos complementares. Exemplos de C\u00f3digo: Exemplos pr\u00e1ticos em Python para cada fase do compilador. F\u00f3rum de Discuss\u00e3o: Espa\u00e7o para tirar d\u00favidas e discutir t\u00f3picos com colegas e instrutores. Projetos: Projetos pr\u00e1ticos para aplicar os conceitos aprendidos.","title":"Recursos Adicionais"},{"location":"#contato","text":"Se tiverem qualquer d\u00favida ou precisarem de ajuda, n\u00e3o hesitem em entrar em contato com os instrutores: Professor Jo\u00e3o Silva: joao.silva@universidade.com Assistente Maria Oliveira: maria.oliveira@universidade.com Estamos aqui para ajudar e garantir que voc\u00eas tenham uma experi\u00eancia de aprendizado enriquecedora e produtiva.","title":"Contato"},{"location":"#conclusao","text":"Estamos muito empolgados em iniciar esta jornada com voc\u00eas. Compiladores s\u00e3o uma parte fundamental da ci\u00eancia da computa\u00e7\u00e3o e esperamos que este curso inspire e capacite voc\u00eas a explorar ainda mais este fascinante campo. Vamos come\u00e7ar! Equipe do M\u00f3dulo de Compiladores","title":"Conclus\u00e3o"},{"location":"#quem-ajusta-o-codigo","text":"Link do formul\u00e1rio: Form","title":"Quem ajusta o c\u00f3digo???"},{"location":"aula1/","text":"Aula 1 - Prazer, Compiladores! \ud83e\udd1d\ud83d\udc7e (Continua\u00e7\u00e3o) A Import\u00e2ncia dos Compiladores Na primeira parte da aula, vimos que os compiladores s\u00e3o como tradutores que transformam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o (que humanos entendem) para uma linguagem que o computador entende (linguagem de m\u00e1quina). Imagine que voc\u00ea quer ensinar um amigo a fazer um bolo, mas ele s\u00f3 fala japon\u00eas. Voc\u00ea precisaria de um tradutor para transmitir as instru\u00e7\u00f5es corretamente, certo? \u00c9 exatamente isso que um compilador faz! Ele garante que o computador compreenda e execute as instru\u00e7\u00f5es do seu programa. Governo Dos States Pede para Parar de Utilizar C e Assembly Fases da Compila\u00e7\u00e3o: Uma An\u00e1lise Detalhada Para um problema: A compila\u00e7\u00e3o, como vimos, \u00e9 um processo dividido em etapas. Vamos entender melhor as tr\u00eas principais: An\u00e1lise L\u00e9xica (Fase do \"dicion\u00e1rio\"): Nesta fase, o compilador age como um leitor que examina o c\u00f3digo letra por letra, agrupando-as em \"palavras\" com significado para a linguagem, como nomes de vari\u00e1veis, palavras-chave (ex.: if , else , for ) e operadores (+, -, *, /). Imagine um corretor ortogr\u00e1fico verificando cada palavra e sinal de pontua\u00e7\u00e3o do seu texto. An\u00e1lise L\u00e9xica e Express\u00f5es Regulares A An\u00e1lise L\u00e9xica \u00e9 a primeira fase de um compilador, respons\u00e1vel por dividir o c\u00f3digo-fonte em uma sequ\u00eancia de tokens. Esses tokens representam as unidades b\u00e1sicas da linguagem, como palavras-chave, identificadores, n\u00fameros, operadores, entre outros. Para realizar a An\u00e1lise L\u00e9xica, uma t\u00e9cnica comumente utilizada s\u00e3o as express\u00f5es regulares (regex). As express\u00f5es regulares s\u00e3o padr\u00f5es que descrevem um conjunto de cadeias de caracteres. Elas permitem identificar e extrair partes espec\u00edficas de um texto com base em regras definidas. As express\u00f5es regulares s\u00e3o compostas por caracteres literais e metacaracteres. Alguns metacaracteres comuns incluem: . (ponto): Corresponde a qualquer caractere, exceto uma nova linha. * (asterisco): Corresponde a zero ou mais ocorr\u00eancias do caractere ou grupo anterior. + (mais): Corresponde a uma ou mais ocorr\u00eancias do caractere ou grupo anterior. ? (interroga\u00e7\u00e3o): Corresponde a zero ou uma ocorr\u00eancia do caractere ou grupo anterior. ^ (circunflexo): Corresponde ao in\u00edcio da linha. $ (cifr\u00e3o): Corresponde ao final da linha. [] (colchetes): Define um conjunto de caracteres. Por exemplo, [aeiou] corresponde a qualquer vogal. Al\u00e9m disso, existem classes de caracteres predefinidas, como: \\d : Corresponde a qualquer d\u00edgito (0-9). \\w : Corresponde a qualquer caractere alfanum\u00e9rico (letra ou d\u00edgito). \\s : Corresponde a qualquer caractere de espa\u00e7o em branco (espa\u00e7o, tabula\u00e7\u00e3o, nova linha). Exemplo de express\u00e3o regular para identificar n\u00fameros inteiros: import re # Express\u00e3o regular para n\u00fameros inteiros pattern = r'\\d+' # Texto de exemplo text = \"Eu tenho 25 anos e meu irm\u00e3o tem 30 anos.\" # Encontrar todos os n\u00fameros inteiros no texto matches = re.findall(pattern, text) # Imprimir os n\u00fameros encontrados for match in matches: print(match) Nesse exemplo, a express\u00e3o regular \\d+ \u00e9 usada para encontrar n\u00fameros inteiros no texto. O m\u00e9todo re.findall() \u00e9 utilizado para encontrar todas as ocorr\u00eancias da express\u00e3o regular no texto. O resultado ser\u00e1: 25 30 As express\u00f5es regulares s\u00e3o uma ferramenta poderosa para a An\u00e1lise L\u00e9xica, permitindo identificar e extrair tokens espec\u00edficos do c\u00f3digo-fonte. Elas podem ser combinadas com outras t\u00e9cnicas, como aut\u00f4matos finitos, para construir um analisador l\u00e9xico completo. No entanto, \u00e9 importante ressaltar que as express\u00f5es regulares t\u00eam suas limita\u00e7\u00f5es. Elas s\u00e3o adequadas para identificar padr\u00f5es simples e regulares, mas podem se tornar complexas e dif\u00edceis de manter para linguagens com estruturas mais complexas. Nesses casos, outras t\u00e9cnicas, como a an\u00e1lise sint\u00e1tica, s\u00e3o necess\u00e1rias para lidar com a estrutura hier\u00e1rquica do c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica (Fase da \"gram\u00e1tica\"): Com as \"palavras\" identificadas, o compilador verifica se elas est\u00e3o organizadas de forma correta, seguindo as regras gramaticais da linguagem. \u00c9 como analisar se a ordem das palavras em uma frase faz sentido. Por exemplo, em portugu\u00eas, dizemos \"O gato comeu o peixe\", e n\u00e3o \"Comeu peixe o gato o\". An\u00e1lise Sint\u00e1tica A An\u00e1lise Sint\u00e1tica \u00e9 a segunda fase de um compilador, que ocorre ap\u00f3s a An\u00e1lise L\u00e9xica. Seu objetivo \u00e9 verificar se a sequ\u00eancia de tokens gerada pela An\u00e1lise L\u00e9xica est\u00e1 de acordo com as regras gramaticais da linguagem de programa\u00e7\u00e3o. Em outras palavras, a An\u00e1lise Sint\u00e1tica verifica se o c\u00f3digo-fonte possui uma estrutura v\u00e1lida. Durante a An\u00e1lise Sint\u00e1tica, o compilador constr\u00f3i uma representa\u00e7\u00e3o estruturada do c\u00f3digo-fonte, geralmente na forma de uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). A AST representa a estrutura hier\u00e1rquica do c\u00f3digo, mostrando a rela\u00e7\u00e3o entre os diferentes elementos da linguagem, como express\u00f5es, comandos e blocos de c\u00f3digo. Existem duas abordagens principais para a An\u00e1lise Sint\u00e1tica: An\u00e1lise Sint\u00e1tica Descendente (Top-Down Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir da regra gramatical mais geral e tenta derivar a sequ\u00eancia de tokens de entrada. O m\u00e9todo mais comum \u00e9 a an\u00e1lise preditiva recursiva, que utiliza recurs\u00e3o para percorrer a gram\u00e1tica e construir a AST. A an\u00e1lise descendente \u00e9 adequada para gram\u00e1ticas LL (Left-to-right, Leftmost derivation), onde \u00e9 poss\u00edvel escolher a regra correta a ser aplicada com base nos pr\u00f3ximos tokens de entrada. An\u00e1lise Sint\u00e1tica Ascendente (Bottom-Up Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir dos tokens de entrada e tenta reduzi-los \u00e0s regras gramaticais at\u00e9 chegar \u00e0 regra inicial. O m\u00e9todo mais comum \u00e9 o LR (Left-to-right, Rightmost derivation), que utiliza uma tabela de an\u00e1lise para determinar as a\u00e7\u00f5es a serem tomadas com base nos tokens de entrada. A an\u00e1lise ascendente \u00e9 adequada para gram\u00e1ticas mais complexas e amb\u00edguas, onde a escolha da regra correta depende dos tokens futuros. Exemplo de An\u00e1lise Sint\u00e1tica usando a abordagem descendente: def parse_expression(tokens): def parse_term(tokens): if tokens[0] == 'NUMBER': return ('NUMBER', tokens.pop(0)[1]) elif tokens[0] == 'LPAREN': tokens.pop(0) expr = parse_expression(tokens) if tokens.pop(0) != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") return expr def parse_factor(tokens): term = parse_term(tokens) while tokens and tokens[0] in ['MULTIPLY', 'DIVIDE']: op = tokens.pop(0) right = parse_term(tokens) term = (op, term, right) return term expr = parse_factor(tokens) while tokens and tokens[0] in ['PLUS', 'MINUS']: op = tokens.pop(0) right = parse_factor(tokens) expr = (op, expr, right) return expr Nesse exemplo, a fun\u00e7\u00e3o parse_expression realiza a an\u00e1lise sint\u00e1tica de uma express\u00e3o aritm\u00e9tica simples. Ela utiliza fun\u00e7\u00f5es auxiliares parse_term e parse_factor para lidar com os diferentes n\u00edveis de preced\u00eancia dos operadores. A an\u00e1lise \u00e9 feita de forma recursiva, consumindo os tokens de entrada e construindo a AST correspondente. A An\u00e1lise Sint\u00e1tica \u00e9 uma fase crucial do compilador, pois garante que o c\u00f3digo-fonte esteja estruturalmente correto antes de prosseguir para as pr\u00f3ximas etapas, como a An\u00e1lise Sem\u00e2ntica e a Gera\u00e7\u00e3o de C\u00f3digo. Ela tamb\u00e9m fornece informa\u00e7\u00f5es importantes sobre a estrutura do programa, que s\u00e3o usadas nas fases posteriores do processo de compila\u00e7\u00e3o. An\u00e1lise Sem\u00e2ntica (Fase da \"interpreta\u00e7\u00e3o\"): Ap\u00f3s a an\u00e1lise sint\u00e1tica, o compilador precisa entender o significado do c\u00f3digo. Ele verifica se as opera\u00e7\u00f5es fazem sentido, se as vari\u00e1veis foram declaradas corretamente e se os tipos de dados s\u00e3o compat\u00edveis. \u00c9 como analisar se as frases em um texto fazem sentido juntas e transmitem a mensagem desejada. Funcionamento de um Compilador Vamos rodar tudo isso em Python! Aqui est\u00e1 um exemplo de programa em Python que demonstra as tr\u00eas fases principais de um compilador: an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica e an\u00e1lise sem\u00e2ntica. import re # Defini\u00e7\u00e3o dos tokens tokens = [ (r'\\d+', 'NUMBER'), (r'\\+', 'PLUS'), (r'\\-', 'MINUS'), (r'\\*', 'MULTIPLY'), (r'\\/', 'DIVIDE'), (r'\\(', 'LPAREN'), (r'\\)', 'RPAREN'), (r'\\s+', 'WHITESPACE') ] # An\u00e1lise L\u00e9xica def lexical_analysis(code): lexemes = [] while code: matched = False for token_expr, token_type in tokens: match = re.match(token_expr, code) if match: value = match.group() if token_type != 'WHITESPACE': lexemes.append((token_type, value)) code = code[len(value):] matched = True break if not matched: raise ValueError(f\"Lexema inv\u00e1lido: {code}\") return lexemes # An\u00e1lise Sint\u00e1tica def syntax_analysis(lexemes): ast = [] while lexemes: token_type, value = lexemes.pop(0) if token_type == 'NUMBER': ast.append(('NUMBER', int(value))) elif token_type in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: ast.append((token_type,)) elif token_type == 'LPAREN': sub_expr = syntax_analysis(lexemes) ast.append(('EXPR', sub_expr)) if lexemes.pop(0)[0] != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") else: raise ValueError(f\"Token inesperado: {token_type}\") return ast # An\u00e1lise Sem\u00e2ntica def semantic_analysis(ast): if isinstance(ast, tuple): if ast[0] == 'NUMBER': return ast[1] elif ast[0] in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: return ast[0] elif ast[0] == 'EXPR': return semantic_analysis(ast[1]) elif isinstance(ast, list): if len(ast) != 3: raise ValueError(\"Express\u00e3o inv\u00e1lida\") left = semantic_analysis(ast[0]) op = semantic_analysis(ast[1]) right = semantic_analysis(ast[2]) if not isinstance(left, int) or not isinstance(right, int): raise ValueError(\"Operandos inv\u00e1lidos\") if op == 'PLUS': return left + right elif op == 'MINUS': return left - right elif op == 'MULTIPLY': return left * right elif op == 'DIVIDE': if right == 0: raise ValueError(\"Divis\u00e3o por zero\") return left // right # Exemplo de uso code = \"2 + (3 * 4) - 5\" print(\"C\u00f3digo fonte:\", code) lexemes = lexical_analysis(code) print(\"An\u00e1lise L\u00e9xica:\", lexemes) ast = syntax_analysis(lexemes) print(\"An\u00e1lise Sint\u00e1tica:\", ast) result = semantic_analysis(ast) print(\"An\u00e1lise Sem\u00e2ntica:\", result) Explica\u00e7\u00e3o do programa: An\u00e1lise L\u00e9xica: Definimos os tokens que o compilador reconhecer\u00e1, como n\u00fameros, operadores e par\u00eanteses. A fun\u00e7\u00e3o lexical_analysis recebe o c\u00f3digo-fonte como entrada e retorna uma lista de lexemas (tokens) encontrados no c\u00f3digo. Utilizamos express\u00f5es regulares para identificar os tokens no c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica: A fun\u00e7\u00e3o syntax_analysis recebe a lista de lexemas como entrada e constr\u00f3i uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). Percorremos os lexemas e constru\u00edmos a AST com base na estrutura da express\u00e3o. Tratamos par\u00eanteses aninhados recursivamente. An\u00e1lise Sem\u00e2ntica: A fun\u00e7\u00e3o semantic_analysis recebe a AST como entrada e realiza a an\u00e1lise sem\u00e2ntica. Percorremos a AST recursivamente e avaliamos a express\u00e3o de acordo com as regras sem\u00e2nticas. Verificamos se os operandos s\u00e3o v\u00e1lidos e realizamos as opera\u00e7\u00f5es aritm\u00e9ticas correspondentes. No exemplo de uso, fornecemos um c\u00f3digo-fonte simples \"2 + (3 * 4) - 5\" e aplicamos as tr\u00eas fases do compilador: 1. An\u00e1lise L\u00e9xica: Obtemos a lista de lexemas. 2. An\u00e1lise Sint\u00e1tica: Constru\u00edmos a AST a partir dos lexemas. 3. An\u00e1lise Sem\u00e2ntica: Avaliamos a express\u00e3o e obtemos o resultado final. Esse programa \u00e9 uma simplifica\u00e7\u00e3o das fases de um compilador e serve para ilustrar os conceitos b\u00e1sicos envolvidos em cada fase. Em um compilador real, essas fases s\u00e3o mais complexas e envolvem mais etapas e detalhes. A Tabela de S\u00edmbolos: Organizando a Informa\u00e7\u00e3o A tabela de s\u00edmbolos \u00e9 como um dicion\u00e1rio que o compilador utiliza para armazenar e organizar informa\u00e7\u00f5es sobre todos os elementos do seu c\u00f3digo, como vari\u00e1veis, fun\u00e7\u00f5es e classes. Imagine que voc\u00ea est\u00e1 organizando uma festa e precisa controlar uma lista de convidados. Para cada convidado, voc\u00ea anota seu nome, n\u00famero de telefone e se ele confirmou presen\u00e7a. A tabela de s\u00edmbolos funciona de maneira similar, guardando informa\u00e7\u00f5es importantes sobre cada elemento do seu c\u00f3digo. Atividade em Sala de Aula Objetivo: Compreender a import\u00e2ncia do Debbuging! Enunciado: Sabe o c\u00f3digo mais acima sobre compila\u00e7\u00e3o em python? Pois \u00e9, ele est\u00e1 quebrado, a sua miss\u00e3o \u00e9 ajustar o c\u00f3digo! Observa\u00e7\u00e3o: Discuta com seus colegas as diferen\u00e7as entre vari\u00e1veis e constantes, e a import\u00e2ncia de definir o tipo de dado para cada elemento.","title":"Aula 1"},{"location":"aula1/#aula-1-prazer-compiladores-continuacao","text":"","title":"Aula 1 - Prazer, Compiladores! \ud83e\udd1d\ud83d\udc7e (Continua\u00e7\u00e3o)"},{"location":"aula1/#a-importancia-dos-compiladores","text":"Na primeira parte da aula, vimos que os compiladores s\u00e3o como tradutores que transformam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o (que humanos entendem) para uma linguagem que o computador entende (linguagem de m\u00e1quina). Imagine que voc\u00ea quer ensinar um amigo a fazer um bolo, mas ele s\u00f3 fala japon\u00eas. Voc\u00ea precisaria de um tradutor para transmitir as instru\u00e7\u00f5es corretamente, certo? \u00c9 exatamente isso que um compilador faz! Ele garante que o computador compreenda e execute as instru\u00e7\u00f5es do seu programa.","title":"A Import\u00e2ncia dos Compiladores"},{"location":"aula1/#governo-dos-states-pede-para-parar-de-utilizar-c-e-assembly","text":"","title":"Governo Dos States Pede para Parar de Utilizar C e Assembly"},{"location":"aula1/#fases-da-compilacao-uma-analise-detalhada","text":"","title":"Fases da Compila\u00e7\u00e3o: Uma An\u00e1lise Detalhada"},{"location":"aula1/#para-um-problema","text":"A compila\u00e7\u00e3o, como vimos, \u00e9 um processo dividido em etapas. Vamos entender melhor as tr\u00eas principais: An\u00e1lise L\u00e9xica (Fase do \"dicion\u00e1rio\"): Nesta fase, o compilador age como um leitor que examina o c\u00f3digo letra por letra, agrupando-as em \"palavras\" com significado para a linguagem, como nomes de vari\u00e1veis, palavras-chave (ex.: if , else , for ) e operadores (+, -, *, /). Imagine um corretor ortogr\u00e1fico verificando cada palavra e sinal de pontua\u00e7\u00e3o do seu texto.","title":"Para um problema:"},{"location":"aula1/#analise-lexica-e-expressoes-regulares","text":"A An\u00e1lise L\u00e9xica \u00e9 a primeira fase de um compilador, respons\u00e1vel por dividir o c\u00f3digo-fonte em uma sequ\u00eancia de tokens. Esses tokens representam as unidades b\u00e1sicas da linguagem, como palavras-chave, identificadores, n\u00fameros, operadores, entre outros. Para realizar a An\u00e1lise L\u00e9xica, uma t\u00e9cnica comumente utilizada s\u00e3o as express\u00f5es regulares (regex). As express\u00f5es regulares s\u00e3o padr\u00f5es que descrevem um conjunto de cadeias de caracteres. Elas permitem identificar e extrair partes espec\u00edficas de um texto com base em regras definidas. As express\u00f5es regulares s\u00e3o compostas por caracteres literais e metacaracteres. Alguns metacaracteres comuns incluem: . (ponto): Corresponde a qualquer caractere, exceto uma nova linha. * (asterisco): Corresponde a zero ou mais ocorr\u00eancias do caractere ou grupo anterior. + (mais): Corresponde a uma ou mais ocorr\u00eancias do caractere ou grupo anterior. ? (interroga\u00e7\u00e3o): Corresponde a zero ou uma ocorr\u00eancia do caractere ou grupo anterior. ^ (circunflexo): Corresponde ao in\u00edcio da linha. $ (cifr\u00e3o): Corresponde ao final da linha. [] (colchetes): Define um conjunto de caracteres. Por exemplo, [aeiou] corresponde a qualquer vogal. Al\u00e9m disso, existem classes de caracteres predefinidas, como: \\d : Corresponde a qualquer d\u00edgito (0-9). \\w : Corresponde a qualquer caractere alfanum\u00e9rico (letra ou d\u00edgito). \\s : Corresponde a qualquer caractere de espa\u00e7o em branco (espa\u00e7o, tabula\u00e7\u00e3o, nova linha). Exemplo de express\u00e3o regular para identificar n\u00fameros inteiros: import re # Express\u00e3o regular para n\u00fameros inteiros pattern = r'\\d+' # Texto de exemplo text = \"Eu tenho 25 anos e meu irm\u00e3o tem 30 anos.\" # Encontrar todos os n\u00fameros inteiros no texto matches = re.findall(pattern, text) # Imprimir os n\u00fameros encontrados for match in matches: print(match) Nesse exemplo, a express\u00e3o regular \\d+ \u00e9 usada para encontrar n\u00fameros inteiros no texto. O m\u00e9todo re.findall() \u00e9 utilizado para encontrar todas as ocorr\u00eancias da express\u00e3o regular no texto. O resultado ser\u00e1: 25 30 As express\u00f5es regulares s\u00e3o uma ferramenta poderosa para a An\u00e1lise L\u00e9xica, permitindo identificar e extrair tokens espec\u00edficos do c\u00f3digo-fonte. Elas podem ser combinadas com outras t\u00e9cnicas, como aut\u00f4matos finitos, para construir um analisador l\u00e9xico completo. No entanto, \u00e9 importante ressaltar que as express\u00f5es regulares t\u00eam suas limita\u00e7\u00f5es. Elas s\u00e3o adequadas para identificar padr\u00f5es simples e regulares, mas podem se tornar complexas e dif\u00edceis de manter para linguagens com estruturas mais complexas. Nesses casos, outras t\u00e9cnicas, como a an\u00e1lise sint\u00e1tica, s\u00e3o necess\u00e1rias para lidar com a estrutura hier\u00e1rquica do c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica (Fase da \"gram\u00e1tica\"): Com as \"palavras\" identificadas, o compilador verifica se elas est\u00e3o organizadas de forma correta, seguindo as regras gramaticais da linguagem. \u00c9 como analisar se a ordem das palavras em uma frase faz sentido. Por exemplo, em portugu\u00eas, dizemos \"O gato comeu o peixe\", e n\u00e3o \"Comeu peixe o gato o\".","title":"An\u00e1lise L\u00e9xica e Express\u00f5es Regulares"},{"location":"aula1/#analise-sintatica","text":"A An\u00e1lise Sint\u00e1tica \u00e9 a segunda fase de um compilador, que ocorre ap\u00f3s a An\u00e1lise L\u00e9xica. Seu objetivo \u00e9 verificar se a sequ\u00eancia de tokens gerada pela An\u00e1lise L\u00e9xica est\u00e1 de acordo com as regras gramaticais da linguagem de programa\u00e7\u00e3o. Em outras palavras, a An\u00e1lise Sint\u00e1tica verifica se o c\u00f3digo-fonte possui uma estrutura v\u00e1lida. Durante a An\u00e1lise Sint\u00e1tica, o compilador constr\u00f3i uma representa\u00e7\u00e3o estruturada do c\u00f3digo-fonte, geralmente na forma de uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). A AST representa a estrutura hier\u00e1rquica do c\u00f3digo, mostrando a rela\u00e7\u00e3o entre os diferentes elementos da linguagem, como express\u00f5es, comandos e blocos de c\u00f3digo. Existem duas abordagens principais para a An\u00e1lise Sint\u00e1tica: An\u00e1lise Sint\u00e1tica Descendente (Top-Down Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir da regra gramatical mais geral e tenta derivar a sequ\u00eancia de tokens de entrada. O m\u00e9todo mais comum \u00e9 a an\u00e1lise preditiva recursiva, que utiliza recurs\u00e3o para percorrer a gram\u00e1tica e construir a AST. A an\u00e1lise descendente \u00e9 adequada para gram\u00e1ticas LL (Left-to-right, Leftmost derivation), onde \u00e9 poss\u00edvel escolher a regra correta a ser aplicada com base nos pr\u00f3ximos tokens de entrada. An\u00e1lise Sint\u00e1tica Ascendente (Bottom-Up Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir dos tokens de entrada e tenta reduzi-los \u00e0s regras gramaticais at\u00e9 chegar \u00e0 regra inicial. O m\u00e9todo mais comum \u00e9 o LR (Left-to-right, Rightmost derivation), que utiliza uma tabela de an\u00e1lise para determinar as a\u00e7\u00f5es a serem tomadas com base nos tokens de entrada. A an\u00e1lise ascendente \u00e9 adequada para gram\u00e1ticas mais complexas e amb\u00edguas, onde a escolha da regra correta depende dos tokens futuros. Exemplo de An\u00e1lise Sint\u00e1tica usando a abordagem descendente: def parse_expression(tokens): def parse_term(tokens): if tokens[0] == 'NUMBER': return ('NUMBER', tokens.pop(0)[1]) elif tokens[0] == 'LPAREN': tokens.pop(0) expr = parse_expression(tokens) if tokens.pop(0) != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") return expr def parse_factor(tokens): term = parse_term(tokens) while tokens and tokens[0] in ['MULTIPLY', 'DIVIDE']: op = tokens.pop(0) right = parse_term(tokens) term = (op, term, right) return term expr = parse_factor(tokens) while tokens and tokens[0] in ['PLUS', 'MINUS']: op = tokens.pop(0) right = parse_factor(tokens) expr = (op, expr, right) return expr Nesse exemplo, a fun\u00e7\u00e3o parse_expression realiza a an\u00e1lise sint\u00e1tica de uma express\u00e3o aritm\u00e9tica simples. Ela utiliza fun\u00e7\u00f5es auxiliares parse_term e parse_factor para lidar com os diferentes n\u00edveis de preced\u00eancia dos operadores. A an\u00e1lise \u00e9 feita de forma recursiva, consumindo os tokens de entrada e construindo a AST correspondente. A An\u00e1lise Sint\u00e1tica \u00e9 uma fase crucial do compilador, pois garante que o c\u00f3digo-fonte esteja estruturalmente correto antes de prosseguir para as pr\u00f3ximas etapas, como a An\u00e1lise Sem\u00e2ntica e a Gera\u00e7\u00e3o de C\u00f3digo. Ela tamb\u00e9m fornece informa\u00e7\u00f5es importantes sobre a estrutura do programa, que s\u00e3o usadas nas fases posteriores do processo de compila\u00e7\u00e3o. An\u00e1lise Sem\u00e2ntica (Fase da \"interpreta\u00e7\u00e3o\"): Ap\u00f3s a an\u00e1lise sint\u00e1tica, o compilador precisa entender o significado do c\u00f3digo. Ele verifica se as opera\u00e7\u00f5es fazem sentido, se as vari\u00e1veis foram declaradas corretamente e se os tipos de dados s\u00e3o compat\u00edveis. \u00c9 como analisar se as frases em um texto fazem sentido juntas e transmitem a mensagem desejada.","title":"An\u00e1lise Sint\u00e1tica"},{"location":"aula1/#funcionamento-de-um-compilador","text":"","title":"Funcionamento de um Compilador"},{"location":"aula1/#vamos-rodar-tudo-isso-em-python","text":"Aqui est\u00e1 um exemplo de programa em Python que demonstra as tr\u00eas fases principais de um compilador: an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica e an\u00e1lise sem\u00e2ntica. import re # Defini\u00e7\u00e3o dos tokens tokens = [ (r'\\d+', 'NUMBER'), (r'\\+', 'PLUS'), (r'\\-', 'MINUS'), (r'\\*', 'MULTIPLY'), (r'\\/', 'DIVIDE'), (r'\\(', 'LPAREN'), (r'\\)', 'RPAREN'), (r'\\s+', 'WHITESPACE') ] # An\u00e1lise L\u00e9xica def lexical_analysis(code): lexemes = [] while code: matched = False for token_expr, token_type in tokens: match = re.match(token_expr, code) if match: value = match.group() if token_type != 'WHITESPACE': lexemes.append((token_type, value)) code = code[len(value):] matched = True break if not matched: raise ValueError(f\"Lexema inv\u00e1lido: {code}\") return lexemes # An\u00e1lise Sint\u00e1tica def syntax_analysis(lexemes): ast = [] while lexemes: token_type, value = lexemes.pop(0) if token_type == 'NUMBER': ast.append(('NUMBER', int(value))) elif token_type in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: ast.append((token_type,)) elif token_type == 'LPAREN': sub_expr = syntax_analysis(lexemes) ast.append(('EXPR', sub_expr)) if lexemes.pop(0)[0] != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") else: raise ValueError(f\"Token inesperado: {token_type}\") return ast # An\u00e1lise Sem\u00e2ntica def semantic_analysis(ast): if isinstance(ast, tuple): if ast[0] == 'NUMBER': return ast[1] elif ast[0] in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: return ast[0] elif ast[0] == 'EXPR': return semantic_analysis(ast[1]) elif isinstance(ast, list): if len(ast) != 3: raise ValueError(\"Express\u00e3o inv\u00e1lida\") left = semantic_analysis(ast[0]) op = semantic_analysis(ast[1]) right = semantic_analysis(ast[2]) if not isinstance(left, int) or not isinstance(right, int): raise ValueError(\"Operandos inv\u00e1lidos\") if op == 'PLUS': return left + right elif op == 'MINUS': return left - right elif op == 'MULTIPLY': return left * right elif op == 'DIVIDE': if right == 0: raise ValueError(\"Divis\u00e3o por zero\") return left // right # Exemplo de uso code = \"2 + (3 * 4) - 5\" print(\"C\u00f3digo fonte:\", code) lexemes = lexical_analysis(code) print(\"An\u00e1lise L\u00e9xica:\", lexemes) ast = syntax_analysis(lexemes) print(\"An\u00e1lise Sint\u00e1tica:\", ast) result = semantic_analysis(ast) print(\"An\u00e1lise Sem\u00e2ntica:\", result) Explica\u00e7\u00e3o do programa: An\u00e1lise L\u00e9xica: Definimos os tokens que o compilador reconhecer\u00e1, como n\u00fameros, operadores e par\u00eanteses. A fun\u00e7\u00e3o lexical_analysis recebe o c\u00f3digo-fonte como entrada e retorna uma lista de lexemas (tokens) encontrados no c\u00f3digo. Utilizamos express\u00f5es regulares para identificar os tokens no c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica: A fun\u00e7\u00e3o syntax_analysis recebe a lista de lexemas como entrada e constr\u00f3i uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). Percorremos os lexemas e constru\u00edmos a AST com base na estrutura da express\u00e3o. Tratamos par\u00eanteses aninhados recursivamente. An\u00e1lise Sem\u00e2ntica: A fun\u00e7\u00e3o semantic_analysis recebe a AST como entrada e realiza a an\u00e1lise sem\u00e2ntica. Percorremos a AST recursivamente e avaliamos a express\u00e3o de acordo com as regras sem\u00e2nticas. Verificamos se os operandos s\u00e3o v\u00e1lidos e realizamos as opera\u00e7\u00f5es aritm\u00e9ticas correspondentes. No exemplo de uso, fornecemos um c\u00f3digo-fonte simples \"2 + (3 * 4) - 5\" e aplicamos as tr\u00eas fases do compilador: 1. An\u00e1lise L\u00e9xica: Obtemos a lista de lexemas. 2. An\u00e1lise Sint\u00e1tica: Constru\u00edmos a AST a partir dos lexemas. 3. An\u00e1lise Sem\u00e2ntica: Avaliamos a express\u00e3o e obtemos o resultado final. Esse programa \u00e9 uma simplifica\u00e7\u00e3o das fases de um compilador e serve para ilustrar os conceitos b\u00e1sicos envolvidos em cada fase. Em um compilador real, essas fases s\u00e3o mais complexas e envolvem mais etapas e detalhes.","title":"Vamos rodar tudo isso em Python!"},{"location":"aula1/#a-tabela-de-simbolos-organizando-a-informacao","text":"A tabela de s\u00edmbolos \u00e9 como um dicion\u00e1rio que o compilador utiliza para armazenar e organizar informa\u00e7\u00f5es sobre todos os elementos do seu c\u00f3digo, como vari\u00e1veis, fun\u00e7\u00f5es e classes. Imagine que voc\u00ea est\u00e1 organizando uma festa e precisa controlar uma lista de convidados. Para cada convidado, voc\u00ea anota seu nome, n\u00famero de telefone e se ele confirmou presen\u00e7a. A tabela de s\u00edmbolos funciona de maneira similar, guardando informa\u00e7\u00f5es importantes sobre cada elemento do seu c\u00f3digo.","title":"A Tabela de S\u00edmbolos: Organizando a Informa\u00e7\u00e3o"},{"location":"aula1/#atividade-em-sala-de-aula","text":"Objetivo: Compreender a import\u00e2ncia do Debbuging! Enunciado: Sabe o c\u00f3digo mais acima sobre compila\u00e7\u00e3o em python? Pois \u00e9, ele est\u00e1 quebrado, a sua miss\u00e3o \u00e9 ajustar o c\u00f3digo! Observa\u00e7\u00e3o: Discuta com seus colegas as diferen\u00e7as entre vari\u00e1veis e constantes, e a import\u00e2ncia de definir o tipo de dado para cada elemento.","title":"Atividade em Sala de Aula"},{"location":"aula2/","text":"Aula 2 - Compila\u00e7\u00e3o e Intera\u00e7\u00e3o: Do C\u00f3digo ao Execut\u00e1vel \ud83d\udcbb\ud83d\udd27 No fascinante mundo da programa\u00e7\u00e3o, as linguagens de programa\u00e7\u00e3o e as linguagens de m\u00e1quina desempenham pap\u00e9is fundamentais na cria\u00e7\u00e3o de software. Embora ambas sejam inven\u00e7\u00f5es humanas, as linguagens de programa\u00e7\u00e3o oferecem uma compreens\u00e3o mais acess\u00edvel, utilizando auxiliares mnem\u00f4nicos e a\u00e7\u00facar sint\u00e1tico para facilitar o processo de desenvolvimento. Por outro lado, a linguagem de m\u00e1quina \u00e9 representada por um arquivo bin\u00e1rio complexo, de dif\u00edcil compreens\u00e3o para os programadores. O que \u00e9 Assembly? \ud83e\udd14 Assembly \u00e9 uma linguagem de baixo n\u00edvel que serve como uma representa\u00e7\u00e3o leg\u00edvel por humanos das instru\u00e7\u00f5es de linguagem de m\u00e1quina. Ela fornece uma abstra\u00e7\u00e3o mais pr\u00f3xima do hardware, permitindo aos programadores um controle mais direto sobre o comportamento do processador. No entanto, escrever c\u00f3digo em Assembly pode ser uma tarefa \u00e1rdua e propensa a erros, especialmente em projetos de grande escala. Diferen\u00e7as entre Compila\u00e7\u00e3o e Interpreta\u00e7\u00e3o \u2696\ufe0f Existem duas abordagens principais para processar o c\u00f3digo-fonte e execut\u00e1-lo em um computador: compila\u00e7\u00e3o e interpreta\u00e7\u00e3o. Vamos explorar as diferen\u00e7as entre essas duas t\u00e9cnicas: Caracter\u00edstica Compila\u00e7\u00e3o Interpreta\u00e7\u00e3o Velocidade de execu\u00e7\u00e3o R\u00e1pida Mais lenta Consumo de recursos Menor Maior Portabilidade Espec\u00edfica da plataforma Independente da plataforma Detec\u00e7\u00e3o de erros Durante a compila\u00e7\u00e3o Durante a execu\u00e7\u00e3o Exemplo de linguagens C, C++, Rust Python, JavaScript, Ruby \ud83d\udd14 \u00c9 importante ressaltar que o c\u00f3digo-fonte processado por meio de interpreta\u00e7\u00e3o oferece maior flexibilidade e facilidade no processo de programa\u00e7\u00e3o. No entanto, essa abordagem consome uma quantidade maior de recursos computacionais e resulta em uma execu\u00e7\u00e3o mais lenta em compara\u00e7\u00e3o com o c\u00f3digo compilado. \u2757 Consumo de Energia: Rust vs. Python \ud83d\udd0b Ao comparar linguagens compiladas e interpretadas, um aspecto interessante a ser considerado \u00e9 o consumo de energia. Vamos analisar a diferen\u00e7a entre Rust, uma linguagem compilada, e Python, uma linguagem interpretada: +---------------+---------------+ | Linguagem | Consumo de | | | Energia | +---------------+---------------+ | Rust | Baixo | +---------------+---------------+ | Python | Alto | +---------------+---------------+ Rust, sendo uma linguagem compilada, \u00e9 conhecida por sua efici\u00eancia energ\u00e9tica. O c\u00f3digo Rust \u00e9 compilado diretamente para instru\u00e7\u00f5es de m\u00e1quina otimizadas, resultando em um consumo de energia menor durante a execu\u00e7\u00e3o. Por outro lado, Python, sendo uma linguagem interpretada, requer a presen\u00e7a de um interpretador para executar o c\u00f3digo. Esse processo adicional de interpreta\u00e7\u00e3o consome mais energia em compara\u00e7\u00e3o com a execu\u00e7\u00e3o direta do c\u00f3digo compilado. Portanto, se a efici\u00eancia energ\u00e9tica for uma preocupa\u00e7\u00e3o crucial para o seu projeto, optar por uma linguagem compilada como Rust pode ser uma escolha mais adequada. Demonstra\u00e7\u00e3o Pr\u00e1tica Tutorial: Instala\u00e7\u00e3o do SDK do .NET 8 e Cria\u00e7\u00e3o de um Projeto MVC \ud83d\ude80 Neste tutorial, vamos aprender como instalar o SDK do .NET 8, criar um novo projeto MVC usando o comando dotnet new mvc e explorar o processo de compila\u00e7\u00e3o. Tamb\u00e9m faremos uma modifica\u00e7\u00e3o no c\u00f3digo para quebrar a compila\u00e7\u00e3o e, em seguida, corrigiremos o c\u00f3digo para que a compila\u00e7\u00e3o seja conclu\u00edda com sucesso. Passo 1: Instala\u00e7\u00e3o do SDK do .NET 8 \ud83d\udce5 Antes de come\u00e7armos, certifique-se de ter o SDK do .NET 8 instalado em seu sistema. Voc\u00ea pode baixar o SDK do .NET 8 a partir do site oficial da Microsoft: Download .NET 8 SDK Siga as instru\u00e7\u00f5es de instala\u00e7\u00e3o espec\u00edficas para o seu sistema operacional. Passo 2: Cria\u00e7\u00e3o de um Novo Projeto MVC \ud83c\udd95 Abra o terminal ou prompt de comando e navegue at\u00e9 o diret\u00f3rio onde deseja criar o projeto. Em seguida, execute o seguinte comando para criar um novo projeto MVC: dotnet new mvc -o MeuProjetoMVC Isso criar\u00e1 uma nova pasta chamada \"MeuProjetoMVC\" contendo a estrutura b\u00e1sica de um projeto MVC. Passo 3: Compila\u00e7\u00e3o do Projeto \u2699\ufe0f Navegue para o diret\u00f3rio do projeto rec\u00e9m-criado: cd MeuProjetoMVC Em seguida, execute o seguinte comando para compilar o projeto: dotnet build Se tudo estiver correto, a compila\u00e7\u00e3o ser\u00e1 conclu\u00edda com sucesso e voc\u00ea ver\u00e1 uma mensagem semelhante a esta: Build succeeded. 0 Warning(s) 0 Error(s) Passo 4: Quebrando a Compila\u00e7\u00e3o \ud83d\udca5 Agora, vamos fazer uma modifica\u00e7\u00e3o no c\u00f3digo para quebrar a compila\u00e7\u00e3o. Abra o arquivo Controllers/HomeController.cs em um editor de texto e adicione um erro de sintaxe intencional. Por exemplo, remova um ponto e v\u00edrgula ( ; ) no final de uma linha. Salve o arquivo e execute novamente o comando dotnet build . Desta vez, a compila\u00e7\u00e3o falhar\u00e1 e voc\u00ea ver\u00e1 uma mensagem de erro indicando o problema: Build failed. 1 Error(s) A mensagem de erro fornecer\u00e1 detalhes sobre o erro de sintaxe que voc\u00ea introduziu. Passo 5: Corrigindo o C\u00f3digo \ud83d\udd27 Agora, vamos corrigir o c\u00f3digo para que a compila\u00e7\u00e3o seja conclu\u00edda com sucesso. Abra novamente o arquivo Controllers/HomeController.cs e corrija o erro de sintaxe que voc\u00ea introduziu anteriormente. Salve o arquivo e execute novamente o comando dotnet build . Desta vez, a compila\u00e7\u00e3o ser\u00e1 conclu\u00edda com sucesso. Principais Livros de Compila\u00e7\u00e3o Claro! Aqui est\u00e1 um resumo dos principais livros sobre compila\u00e7\u00e3o e compiladores, que s\u00e3o essenciais para quem deseja aprofundar seus conhecimentos nessa \u00e1rea: 1. \"Compilers: Principles, Techniques, and Tools\" (Dragon Book) Autores: Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman Resumo: Conhecido como o \"Dragon Book\" devido \u00e0 ilustra\u00e7\u00e3o de um drag\u00e3o na capa, este livro \u00e9 considerado a b\u00edblia dos compiladores. Ele cobre todos os aspectos fundamentais da constru\u00e7\u00e3o de compiladores, incluindo an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica, an\u00e1lise sem\u00e2ntica, otimiza\u00e7\u00e3o de c\u00f3digo, gera\u00e7\u00e3o de c\u00f3digo e t\u00e9cnicas de compila\u00e7\u00e3o avan\u00e7adas. \u00c9 amplamente utilizado em cursos universit\u00e1rios e \u00e9 uma refer\u00eancia essencial para qualquer pessoa interessada em compiladores. 2. \"Engineering a Compiler\" Autores: Keith D. Cooper, Linda Torczon Resumo: Este livro oferece uma abordagem pr\u00e1tica e detalhada para a engenharia de compiladores. Ele aborda os princ\u00edpios b\u00e1sicos e as t\u00e9cnicas avan\u00e7adas de constru\u00e7\u00e3o de compiladores, com \u00eanfase em exemplos pr\u00e1ticos e implementa\u00e7\u00f5es reais. \u00c9 ideal para estudantes e profissionais que desejam entender como os compiladores funcionam na pr\u00e1tica e como aplicar esses conhecimentos em projetos reais. 3. \"Modern Compiler Implementation in C/Java/ML\" Autor: Andrew W. Appel Resumo: Esta s\u00e9rie de livros, dispon\u00edvel em vers\u00f5es para C, Java e ML, fornece uma introdu\u00e7\u00e3o pr\u00e1tica \u00e0 implementa\u00e7\u00e3o de compiladores. Cada vers\u00e3o do livro \u00e9 adaptada para a linguagem de programa\u00e7\u00e3o espec\u00edfica, oferecendo exemplos e exerc\u00edcios pr\u00e1ticos. O livro cobre t\u00f3picos como an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica, gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio, otimiza\u00e7\u00e3o e gera\u00e7\u00e3o de c\u00f3digo final. \u00c9 uma excelente escolha para quem deseja aprender a implementar compiladores em uma linguagem espec\u00edfica. 4. \"Advanced Compiler Design and Implementation\" Autor: Steven Muchnick Resumo: Este livro \u00e9 voltado para leitores que j\u00e1 possuem um conhecimento b\u00e1sico sobre compiladores e desejam explorar t\u00e9cnicas avan\u00e7adas de design e implementa\u00e7\u00e3o. Ele cobre t\u00f3picos como otimiza\u00e7\u00e3o de c\u00f3digo, an\u00e1lise de depend\u00eancias, paralelismo, e t\u00e9cnicas de compila\u00e7\u00e3o para arquiteturas modernas. \u00c9 uma leitura essencial para quem deseja aprofundar seus conhecimentos e trabalhar em projetos de compiladores de alto desempenho. 5. \"The Definitive ANTLR 4 Reference\" Autor: Terence Parr Resumo: Este livro \u00e9 um guia completo para o ANTLR (Another Tool for Language Recognition), uma ferramenta popular para a constru\u00e7\u00e3o de analisadores l\u00e9xicos e sint\u00e1ticos. Ele fornece uma introdu\u00e7\u00e3o pr\u00e1tica ao uso do ANTLR, com exemplos detalhados e explica\u00e7\u00f5es claras. \u00c9 ideal para desenvolvedores que desejam criar linguagens de dom\u00ednio espec\u00edfico (DSLs) ou trabalhar com an\u00e1lise de linguagem. 6. \"Programming Language Pragmatics\" Autor: Michael L. Scott Resumo: Embora n\u00e3o seja exclusivamente sobre compiladores, este livro oferece uma vis\u00e3o abrangente sobre a teoria e a pr\u00e1tica das linguagens de programa\u00e7\u00e3o, incluindo a constru\u00e7\u00e3o de compiladores. Ele aborda t\u00f3picos como sem\u00e2ntica de linguagem, design de linguagem, e t\u00e9cnicas de implementa\u00e7\u00e3o. \u00c9 uma excelente leitura para entender o contexto mais amplo em que os compiladores operam. An\u00e1lise L\u00e9xica: Gera\u00e7\u00e3o de Tokens em Detalhes \ud83d\udd0d\ud83d\udcc4 Nesta aula, vamos explorar a an\u00e1lise l\u00e9xica e a gera\u00e7\u00e3o de tokens em detalhes, utilizando a linguagem de programa\u00e7\u00e3o Python. A an\u00e1lise l\u00e9xica \u00e9 a primeira fase do processo de compila\u00e7\u00e3o, onde o c\u00f3digo-fonte \u00e9 dividido em unidades menores chamadas tokens. O que s\u00e3o Tokens? \ud83c\udfab Tokens s\u00e3o unidades b\u00e1sicas de um programa que possuem um significado pr\u00f3prio. Eles podem ser palavras-chave, identificadores, literais, operadores ou s\u00edmbolos especiais. Cada token \u00e9 classificado de acordo com sua categoria l\u00e9xica. Exemplo de C\u00f3digo-Fonte \ud83d\udcbb Vou demonstrar como isso funciona com uma equa\u00e7\u00e3o simples em C#. Vamos considerar a seguinte equa\u00e7\u00e3o em C#: int result = 3 + 5 * (2 - 8); Passos da An\u00e1lise L\u00e9xica Entrada do C\u00f3digo-Fonte: csharp int result = 3 + 5 * (2 - 8); Divis\u00e3o em Tokens: A an\u00e1lise l\u00e9xica divide o c\u00f3digo-fonte em unidades menores chamadas tokens. Cada token representa uma unidade sint\u00e1tica do c\u00f3digo, como palavras-chave, identificadores, operadores, literais, etc. Tabela de Tokens: Aqui est\u00e1 a tabela de tokens gerada a partir da equa\u00e7\u00e3o acima: Token Tipo Descri\u00e7\u00e3o int Palavra-chave Tipo de dado inteiro result Identificador Nome da vari\u00e1vel = Operador Operador de atribui\u00e7\u00e3o 3 Literal N\u00famero inteiro + Operador Operador de adi\u00e7\u00e3o 5 Literal N\u00famero inteiro * Operador Operador de multiplica\u00e7\u00e3o ( Delimitador Par\u00eantese de abertura 2 Literal N\u00famero inteiro - Operador Operador de subtra\u00e7\u00e3o 8 Literal N\u00famero inteiro ) Delimitador Par\u00eantese de fechamento ; Delimitador Ponto e v\u00edrgula (fim da instru\u00e7\u00e3o) Explica\u00e7\u00e3o Detalhada Palavras-chave: S\u00e3o termos reservados pela linguagem de programa\u00e7\u00e3o. No exemplo, int \u00e9 uma palavra-chave que indica que a vari\u00e1vel result \u00e9 do tipo inteiro. Identificadores: S\u00e3o nomes dados a vari\u00e1veis, fun\u00e7\u00f5es, classes, etc. No exemplo, result \u00e9 um identificador. Operadores: S\u00e3o s\u00edmbolos que representam opera\u00e7\u00f5es. No exemplo, = , + , * , e - s\u00e3o operadores. Literais: S\u00e3o valores constantes diretamente representados no c\u00f3digo. No exemplo, 3 , 5 , 2 , e 8 s\u00e3o literais inteiros. Delimitadores: S\u00e3o caracteres que delimitam estruturas de c\u00f3digo. No exemplo, ( , ) , e ; s\u00e3o delimitadores. Palavras-chave: S\u00e3o termos reservados pela linguagem de programa\u00e7\u00e3o. No exemplo, int \u00e9 uma palavra-chave que indica que a vari\u00e1vel result \u00e9 do tipo inteiro. Identificadores: S\u00e3o nomes dados a vari\u00e1veis, fun\u00e7\u00f5es, classes, etc. No exemplo, result \u00e9 um identificador. Operadores: S\u00e3o s\u00edmbolos que representam opera\u00e7\u00f5es. No exemplo, = , + , * , e - s\u00e3o operadores. Literais: S\u00e3o valores constantes diretamente representados no c\u00f3digo. No exemplo, 3 , 5 , 2 , e 8 s\u00e3o literais inteiros. Delimitadores: S\u00e3o caracteres que delimitam estruturas de c\u00f3digo. No exemplo, ( , ) , e ; s\u00e3o delimitadores. Implementa\u00e7\u00e3o do Analisador L\u00e9xico em Python \ud83d\udc0d Agora, vamos implementar um analisador l\u00e9xico simples em Python para gerar os tokens a partir do c\u00f3digo-fonte acima. import re def tokenize(code): # Defini\u00e7\u00e3o das express\u00f5es regulares para cada tipo de token token_specs = [ ('KEYWORD', r'if|then|else|end|print'), ('IDENTIFIER', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('NUMBER', r'\\d+(\\.\\d+)?'), ('OPERATOR', r'[><=!+\\-*/%]'), ('STRING', r'\".*?\"'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('NEWLINE', r'\\n'), ('SKIP', r'[ \\t]+'), ] # Compila\u00e7\u00e3o das express\u00f5es regulares token_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs) regex = re.compile(token_regex) # Gera\u00e7\u00e3o dos tokens tokens = [] for match in regex.finditer(code): token_type = match.lastgroup token_value = match.group(token_type) if token_type != 'SKIP': tokens.append((token_type, token_value)) return tokens # C\u00f3digo-fonte de exemplo code = ''' if x > 10 then print(\"Hello, World!\") else print(\"x is less than or equal to 10\") end ''' # Chamada da fun\u00e7\u00e3o de tokeniza\u00e7\u00e3o tokens = tokenize(code) # Impress\u00e3o dos tokens gerados for token in tokens: print(token) Neste exemplo, utilizamos express\u00f5es regulares para definir os padr\u00f5es de cada tipo de token. Em seguida, compilamos essas express\u00f5es regulares em um \u00fanico padr\u00e3o usando o m\u00f3dulo re do Python. A fun\u00e7\u00e3o tokenize recebe o c\u00f3digo-fonte como entrada e itera sobre as correspond\u00eancias encontradas pelo padr\u00e3o de express\u00e3o regular. Para cada correspond\u00eancia, extra\u00edmos o tipo de token e seu valor. Ignoramos os tokens do tipo SKIP , que representam espa\u00e7os em branco e tabula\u00e7\u00f5es. Por fim, imprimimos os tokens gerados, que ser\u00e3o semelhantes a: ('KEYWORD', 'if') ('IDENTIFIER', 'x') ('OPERATOR', '>') ('NUMBER', '10') ('KEYWORD', 'then') ('KEYWORD', 'print') ('LPAREN', '(') ('STRING', '\"Hello, World!\"') ('RPAREN', ')') ('KEYWORD', 'else') ('KEYWORD', 'print') ('LPAREN', '(') ('STRING', '\"x is less than or equal to 10\"') ('RPAREN', ')') ('KEYWORD', 'end') Cada token \u00e9 representado por uma tupla contendo o tipo de token e seu valor correspondente. Vamos Brincar no Colab! Claro! Vamos refazer o exemplo anterior e criar uma tabela de s\u00edmbolos usando o pandas no Google Colab. Aqui est\u00e1 o c\u00f3digo atualizado: import re import pandas as pd def tokenize(code): # Defini\u00e7\u00e3o das express\u00f5es regulares para cada tipo de token token_specs = [ ('KEYWORD', r'if|then|else|end|print'), ('IDENTIFIER', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('NUMBER', r'\\d+(\\.\\d+)?'), ('OPERATOR', r'[><=!+\\-*/%]'), ('STRING', r'\".*?\"'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('NEWLINE', r'\\n'), ('SKIP', r'[ \\t]+'), ] # Compila\u00e7\u00e3o das express\u00f5es regulares token_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs) regex = re.compile(token_regex) # Gera\u00e7\u00e3o dos tokens tokens = [] for match in regex.finditer(code): token_type = match.lastgroup token_value = match.group(token_type) if token_type != 'SKIP': tokens.append((token_type, token_value)) return tokens # C\u00f3digo-fonte de exemplo code = ''' if x > 10 then print(\"Hello, World!\") else print(\"x is less than or equal to 10\") end ''' # Chamada da fun\u00e7\u00e3o de tokeniza\u00e7\u00e3o tokens = tokenize(code) # Cria\u00e7\u00e3o da tabela de s\u00edmbolos usando o pandas symbol_table = pd.DataFrame(tokens, columns=['Token Type', 'Token Value']) # Impress\u00e3o da tabela de s\u00edmbolos print(\"Tabela de S\u00edmbolos:\") print(symbol_table) Neste exemplo atualizado, utilizamos o pandas para criar uma tabela de s\u00edmbolos a partir dos tokens gerados. Ap\u00f3s chamar a fun\u00e7\u00e3o tokenize com o c\u00f3digo-fonte de exemplo, criamos um DataFrame do pandas chamado symbol_table usando os tokens como dados e especificando as colunas como \"Token Type\" e \"Token Value\". Por fim, imprimimos a tabela de s\u00edmbolos usando o m\u00e9todo print . Ao executar este c\u00f3digo no Google Colab, voc\u00ea ver\u00e1 a seguinte sa\u00edda: Tabela de S\u00edmbolos: Token Type Token Value 0 KEYWORD if 1 IDENTIFIER x 2 OPERATOR > 3 NUMBER 10 4 KEYWORD then 5 KEYWORD print 6 LPAREN ( 7 STRING \"Hello, World!\" 8 RPAREN ) 9 KEYWORD else 10 KEYWORD print 11 LPAREN ( 12 STRING \"x is less than or equal to 10\" 13 RPAREN ) 14 KEYWORD end A tabela de s\u00edmbolos exibe cada token encontrado no c\u00f3digo-fonte, juntamente com seu tipo de token correspondente. Conclus\u00e3o \ud83c\udf89 Compila\u00e7\u00e3o e interpreta\u00e7\u00e3o s\u00e3o duas abordagens distintas para processar o c\u00f3digo-fonte e execut\u00e1-lo em um computador. Enquanto a compila\u00e7\u00e3o oferece maior velocidade de execu\u00e7\u00e3o e menor consumo de recursos, a interpreta\u00e7\u00e3o proporciona maior flexibilidade e portabilidade. A escolha entre essas abordagens depende dos requisitos espec\u00edficos do projeto, levando em considera\u00e7\u00e3o fatores como desempenho, consumo de energia e facilidade de desenvolvimento. Ao compreender as diferen\u00e7as entre compila\u00e7\u00e3o e interpreta\u00e7\u00e3o, os programadores podem tomar decis\u00f5es informadas sobre qual abordagem adotar para seus projetos, buscando o equil\u00edbrio ideal entre efici\u00eancia e produtividade. \ud83d\ude80 Indica\u00e7\u00e3o de Livros: Link: Programa\u00e7\u00e3o Funcional e Concorrente em Rust Link: ASP.NET Core MVC","title":"Aula 2"},{"location":"aula2/#aula-2-compilacao-e-interacao-do-codigo-ao-executavel","text":"No fascinante mundo da programa\u00e7\u00e3o, as linguagens de programa\u00e7\u00e3o e as linguagens de m\u00e1quina desempenham pap\u00e9is fundamentais na cria\u00e7\u00e3o de software. Embora ambas sejam inven\u00e7\u00f5es humanas, as linguagens de programa\u00e7\u00e3o oferecem uma compreens\u00e3o mais acess\u00edvel, utilizando auxiliares mnem\u00f4nicos e a\u00e7\u00facar sint\u00e1tico para facilitar o processo de desenvolvimento. Por outro lado, a linguagem de m\u00e1quina \u00e9 representada por um arquivo bin\u00e1rio complexo, de dif\u00edcil compreens\u00e3o para os programadores.","title":"Aula 2 - Compila\u00e7\u00e3o e Intera\u00e7\u00e3o: Do C\u00f3digo ao Execut\u00e1vel \ud83d\udcbb\ud83d\udd27"},{"location":"aula2/#o-que-e-assembly","text":"Assembly \u00e9 uma linguagem de baixo n\u00edvel que serve como uma representa\u00e7\u00e3o leg\u00edvel por humanos das instru\u00e7\u00f5es de linguagem de m\u00e1quina. Ela fornece uma abstra\u00e7\u00e3o mais pr\u00f3xima do hardware, permitindo aos programadores um controle mais direto sobre o comportamento do processador. No entanto, escrever c\u00f3digo em Assembly pode ser uma tarefa \u00e1rdua e propensa a erros, especialmente em projetos de grande escala.","title":"O que \u00e9 Assembly? \ud83e\udd14"},{"location":"aula2/#diferencas-entre-compilacao-e-interpretacao","text":"Existem duas abordagens principais para processar o c\u00f3digo-fonte e execut\u00e1-lo em um computador: compila\u00e7\u00e3o e interpreta\u00e7\u00e3o. Vamos explorar as diferen\u00e7as entre essas duas t\u00e9cnicas: Caracter\u00edstica Compila\u00e7\u00e3o Interpreta\u00e7\u00e3o Velocidade de execu\u00e7\u00e3o R\u00e1pida Mais lenta Consumo de recursos Menor Maior Portabilidade Espec\u00edfica da plataforma Independente da plataforma Detec\u00e7\u00e3o de erros Durante a compila\u00e7\u00e3o Durante a execu\u00e7\u00e3o Exemplo de linguagens C, C++, Rust Python, JavaScript, Ruby \ud83d\udd14 \u00c9 importante ressaltar que o c\u00f3digo-fonte processado por meio de interpreta\u00e7\u00e3o oferece maior flexibilidade e facilidade no processo de programa\u00e7\u00e3o. No entanto, essa abordagem consome uma quantidade maior de recursos computacionais e resulta em uma execu\u00e7\u00e3o mais lenta em compara\u00e7\u00e3o com o c\u00f3digo compilado. \u2757","title":"Diferen\u00e7as entre Compila\u00e7\u00e3o e Interpreta\u00e7\u00e3o \u2696\ufe0f"},{"location":"aula2/#consumo-de-energia-rust-vs-python","text":"Ao comparar linguagens compiladas e interpretadas, um aspecto interessante a ser considerado \u00e9 o consumo de energia. Vamos analisar a diferen\u00e7a entre Rust, uma linguagem compilada, e Python, uma linguagem interpretada: +---------------+---------------+ | Linguagem | Consumo de | | | Energia | +---------------+---------------+ | Rust | Baixo | +---------------+---------------+ | Python | Alto | +---------------+---------------+ Rust, sendo uma linguagem compilada, \u00e9 conhecida por sua efici\u00eancia energ\u00e9tica. O c\u00f3digo Rust \u00e9 compilado diretamente para instru\u00e7\u00f5es de m\u00e1quina otimizadas, resultando em um consumo de energia menor durante a execu\u00e7\u00e3o. Por outro lado, Python, sendo uma linguagem interpretada, requer a presen\u00e7a de um interpretador para executar o c\u00f3digo. Esse processo adicional de interpreta\u00e7\u00e3o consome mais energia em compara\u00e7\u00e3o com a execu\u00e7\u00e3o direta do c\u00f3digo compilado. Portanto, se a efici\u00eancia energ\u00e9tica for uma preocupa\u00e7\u00e3o crucial para o seu projeto, optar por uma linguagem compilada como Rust pode ser uma escolha mais adequada.","title":"Consumo de Energia: Rust vs. Python \ud83d\udd0b"},{"location":"aula2/#demonstracao-pratica","text":"","title":"Demonstra\u00e7\u00e3o Pr\u00e1tica"},{"location":"aula2/#tutorial-instalacao-do-sdk-do-net-8-e-criacao-de-um-projeto-mvc","text":"Neste tutorial, vamos aprender como instalar o SDK do .NET 8, criar um novo projeto MVC usando o comando dotnet new mvc e explorar o processo de compila\u00e7\u00e3o. Tamb\u00e9m faremos uma modifica\u00e7\u00e3o no c\u00f3digo para quebrar a compila\u00e7\u00e3o e, em seguida, corrigiremos o c\u00f3digo para que a compila\u00e7\u00e3o seja conclu\u00edda com sucesso.","title":"Tutorial: Instala\u00e7\u00e3o do SDK do .NET 8 e Cria\u00e7\u00e3o de um Projeto MVC \ud83d\ude80"},{"location":"aula2/#passo-1-instalacao-do-sdk-do-net-8","text":"Antes de come\u00e7armos, certifique-se de ter o SDK do .NET 8 instalado em seu sistema. Voc\u00ea pode baixar o SDK do .NET 8 a partir do site oficial da Microsoft: Download .NET 8 SDK Siga as instru\u00e7\u00f5es de instala\u00e7\u00e3o espec\u00edficas para o seu sistema operacional.","title":"Passo 1: Instala\u00e7\u00e3o do SDK do .NET 8 \ud83d\udce5"},{"location":"aula2/#passo-2-criacao-de-um-novo-projeto-mvc","text":"Abra o terminal ou prompt de comando e navegue at\u00e9 o diret\u00f3rio onde deseja criar o projeto. Em seguida, execute o seguinte comando para criar um novo projeto MVC: dotnet new mvc -o MeuProjetoMVC Isso criar\u00e1 uma nova pasta chamada \"MeuProjetoMVC\" contendo a estrutura b\u00e1sica de um projeto MVC.","title":"Passo 2: Cria\u00e7\u00e3o de um Novo Projeto MVC \ud83c\udd95"},{"location":"aula2/#passo-3-compilacao-do-projeto","text":"Navegue para o diret\u00f3rio do projeto rec\u00e9m-criado: cd MeuProjetoMVC Em seguida, execute o seguinte comando para compilar o projeto: dotnet build Se tudo estiver correto, a compila\u00e7\u00e3o ser\u00e1 conclu\u00edda com sucesso e voc\u00ea ver\u00e1 uma mensagem semelhante a esta: Build succeeded. 0 Warning(s) 0 Error(s)","title":"Passo 3: Compila\u00e7\u00e3o do Projeto \u2699\ufe0f"},{"location":"aula2/#passo-4-quebrando-a-compilacao","text":"Agora, vamos fazer uma modifica\u00e7\u00e3o no c\u00f3digo para quebrar a compila\u00e7\u00e3o. Abra o arquivo Controllers/HomeController.cs em um editor de texto e adicione um erro de sintaxe intencional. Por exemplo, remova um ponto e v\u00edrgula ( ; ) no final de uma linha. Salve o arquivo e execute novamente o comando dotnet build . Desta vez, a compila\u00e7\u00e3o falhar\u00e1 e voc\u00ea ver\u00e1 uma mensagem de erro indicando o problema: Build failed. 1 Error(s) A mensagem de erro fornecer\u00e1 detalhes sobre o erro de sintaxe que voc\u00ea introduziu.","title":"Passo 4: Quebrando a Compila\u00e7\u00e3o \ud83d\udca5"},{"location":"aula2/#passo-5-corrigindo-o-codigo","text":"Agora, vamos corrigir o c\u00f3digo para que a compila\u00e7\u00e3o seja conclu\u00edda com sucesso. Abra novamente o arquivo Controllers/HomeController.cs e corrija o erro de sintaxe que voc\u00ea introduziu anteriormente. Salve o arquivo e execute novamente o comando dotnet build . Desta vez, a compila\u00e7\u00e3o ser\u00e1 conclu\u00edda com sucesso.","title":"Passo 5: Corrigindo o C\u00f3digo \ud83d\udd27"},{"location":"aula2/#principais-livros-de-compilacao","text":"Claro! Aqui est\u00e1 um resumo dos principais livros sobre compila\u00e7\u00e3o e compiladores, que s\u00e3o essenciais para quem deseja aprofundar seus conhecimentos nessa \u00e1rea:","title":"Principais Livros de Compila\u00e7\u00e3o"},{"location":"aula2/#1-compilers-principles-techniques-and-tools-dragon-book","text":"Autores: Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman","title":"1. \"Compilers: Principles, Techniques, and Tools\" (Dragon Book)"},{"location":"aula2/#resumo","text":"Conhecido como o \"Dragon Book\" devido \u00e0 ilustra\u00e7\u00e3o de um drag\u00e3o na capa, este livro \u00e9 considerado a b\u00edblia dos compiladores. Ele cobre todos os aspectos fundamentais da constru\u00e7\u00e3o de compiladores, incluindo an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica, an\u00e1lise sem\u00e2ntica, otimiza\u00e7\u00e3o de c\u00f3digo, gera\u00e7\u00e3o de c\u00f3digo e t\u00e9cnicas de compila\u00e7\u00e3o avan\u00e7adas. \u00c9 amplamente utilizado em cursos universit\u00e1rios e \u00e9 uma refer\u00eancia essencial para qualquer pessoa interessada em compiladores.","title":"Resumo:"},{"location":"aula2/#2-engineering-a-compiler","text":"Autores: Keith D. Cooper, Linda Torczon","title":"2. \"Engineering a Compiler\""},{"location":"aula2/#resumo_1","text":"Este livro oferece uma abordagem pr\u00e1tica e detalhada para a engenharia de compiladores. Ele aborda os princ\u00edpios b\u00e1sicos e as t\u00e9cnicas avan\u00e7adas de constru\u00e7\u00e3o de compiladores, com \u00eanfase em exemplos pr\u00e1ticos e implementa\u00e7\u00f5es reais. \u00c9 ideal para estudantes e profissionais que desejam entender como os compiladores funcionam na pr\u00e1tica e como aplicar esses conhecimentos em projetos reais.","title":"Resumo:"},{"location":"aula2/#3-modern-compiler-implementation-in-cjavaml","text":"Autor: Andrew W. Appel","title":"3. \"Modern Compiler Implementation in C/Java/ML\""},{"location":"aula2/#resumo_2","text":"Esta s\u00e9rie de livros, dispon\u00edvel em vers\u00f5es para C, Java e ML, fornece uma introdu\u00e7\u00e3o pr\u00e1tica \u00e0 implementa\u00e7\u00e3o de compiladores. Cada vers\u00e3o do livro \u00e9 adaptada para a linguagem de programa\u00e7\u00e3o espec\u00edfica, oferecendo exemplos e exerc\u00edcios pr\u00e1ticos. O livro cobre t\u00f3picos como an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica, gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio, otimiza\u00e7\u00e3o e gera\u00e7\u00e3o de c\u00f3digo final. \u00c9 uma excelente escolha para quem deseja aprender a implementar compiladores em uma linguagem espec\u00edfica.","title":"Resumo:"},{"location":"aula2/#4-advanced-compiler-design-and-implementation","text":"Autor: Steven Muchnick","title":"4. \"Advanced Compiler Design and Implementation\""},{"location":"aula2/#resumo_3","text":"Este livro \u00e9 voltado para leitores que j\u00e1 possuem um conhecimento b\u00e1sico sobre compiladores e desejam explorar t\u00e9cnicas avan\u00e7adas de design e implementa\u00e7\u00e3o. Ele cobre t\u00f3picos como otimiza\u00e7\u00e3o de c\u00f3digo, an\u00e1lise de depend\u00eancias, paralelismo, e t\u00e9cnicas de compila\u00e7\u00e3o para arquiteturas modernas. \u00c9 uma leitura essencial para quem deseja aprofundar seus conhecimentos e trabalhar em projetos de compiladores de alto desempenho.","title":"Resumo:"},{"location":"aula2/#5-the-definitive-antlr-4-reference","text":"Autor: Terence Parr","title":"5. \"The Definitive ANTLR 4 Reference\""},{"location":"aula2/#resumo_4","text":"Este livro \u00e9 um guia completo para o ANTLR (Another Tool for Language Recognition), uma ferramenta popular para a constru\u00e7\u00e3o de analisadores l\u00e9xicos e sint\u00e1ticos. Ele fornece uma introdu\u00e7\u00e3o pr\u00e1tica ao uso do ANTLR, com exemplos detalhados e explica\u00e7\u00f5es claras. \u00c9 ideal para desenvolvedores que desejam criar linguagens de dom\u00ednio espec\u00edfico (DSLs) ou trabalhar com an\u00e1lise de linguagem.","title":"Resumo:"},{"location":"aula2/#6-programming-language-pragmatics","text":"Autor: Michael L. Scott","title":"6. \"Programming Language Pragmatics\""},{"location":"aula2/#resumo_5","text":"Embora n\u00e3o seja exclusivamente sobre compiladores, este livro oferece uma vis\u00e3o abrangente sobre a teoria e a pr\u00e1tica das linguagens de programa\u00e7\u00e3o, incluindo a constru\u00e7\u00e3o de compiladores. Ele aborda t\u00f3picos como sem\u00e2ntica de linguagem, design de linguagem, e t\u00e9cnicas de implementa\u00e7\u00e3o. \u00c9 uma excelente leitura para entender o contexto mais amplo em que os compiladores operam.","title":"Resumo:"},{"location":"aula2/#analise-lexica-geracao-de-tokens-em-detalhes","text":"Nesta aula, vamos explorar a an\u00e1lise l\u00e9xica e a gera\u00e7\u00e3o de tokens em detalhes, utilizando a linguagem de programa\u00e7\u00e3o Python. A an\u00e1lise l\u00e9xica \u00e9 a primeira fase do processo de compila\u00e7\u00e3o, onde o c\u00f3digo-fonte \u00e9 dividido em unidades menores chamadas tokens.","title":"An\u00e1lise L\u00e9xica: Gera\u00e7\u00e3o de Tokens em Detalhes \ud83d\udd0d\ud83d\udcc4"},{"location":"aula2/#o-que-sao-tokens","text":"Tokens s\u00e3o unidades b\u00e1sicas de um programa que possuem um significado pr\u00f3prio. Eles podem ser palavras-chave, identificadores, literais, operadores ou s\u00edmbolos especiais. Cada token \u00e9 classificado de acordo com sua categoria l\u00e9xica.","title":"O que s\u00e3o Tokens? \ud83c\udfab"},{"location":"aula2/#exemplo-de-codigo-fonte","text":"Vou demonstrar como isso funciona com uma equa\u00e7\u00e3o simples em C#. Vamos considerar a seguinte equa\u00e7\u00e3o em C#: int result = 3 + 5 * (2 - 8);","title":"Exemplo de C\u00f3digo-Fonte \ud83d\udcbb"},{"location":"aula2/#passos-da-analise-lexica","text":"Entrada do C\u00f3digo-Fonte: csharp int result = 3 + 5 * (2 - 8); Divis\u00e3o em Tokens: A an\u00e1lise l\u00e9xica divide o c\u00f3digo-fonte em unidades menores chamadas tokens. Cada token representa uma unidade sint\u00e1tica do c\u00f3digo, como palavras-chave, identificadores, operadores, literais, etc. Tabela de Tokens: Aqui est\u00e1 a tabela de tokens gerada a partir da equa\u00e7\u00e3o acima: Token Tipo Descri\u00e7\u00e3o int Palavra-chave Tipo de dado inteiro result Identificador Nome da vari\u00e1vel = Operador Operador de atribui\u00e7\u00e3o 3 Literal N\u00famero inteiro + Operador Operador de adi\u00e7\u00e3o 5 Literal N\u00famero inteiro * Operador Operador de multiplica\u00e7\u00e3o ( Delimitador Par\u00eantese de abertura 2 Literal N\u00famero inteiro - Operador Operador de subtra\u00e7\u00e3o 8 Literal N\u00famero inteiro ) Delimitador Par\u00eantese de fechamento ; Delimitador Ponto e v\u00edrgula (fim da instru\u00e7\u00e3o)","title":"Passos da An\u00e1lise L\u00e9xica"},{"location":"aula2/#explicacao-detalhada","text":"Palavras-chave: S\u00e3o termos reservados pela linguagem de programa\u00e7\u00e3o. No exemplo, int \u00e9 uma palavra-chave que indica que a vari\u00e1vel result \u00e9 do tipo inteiro. Identificadores: S\u00e3o nomes dados a vari\u00e1veis, fun\u00e7\u00f5es, classes, etc. No exemplo, result \u00e9 um identificador. Operadores: S\u00e3o s\u00edmbolos que representam opera\u00e7\u00f5es. No exemplo, = , + , * , e - s\u00e3o operadores. Literais: S\u00e3o valores constantes diretamente representados no c\u00f3digo. No exemplo, 3 , 5 , 2 , e 8 s\u00e3o literais inteiros. Delimitadores: S\u00e3o caracteres que delimitam estruturas de c\u00f3digo. No exemplo, ( , ) , e ; s\u00e3o delimitadores. Palavras-chave: S\u00e3o termos reservados pela linguagem de programa\u00e7\u00e3o. No exemplo, int \u00e9 uma palavra-chave que indica que a vari\u00e1vel result \u00e9 do tipo inteiro. Identificadores: S\u00e3o nomes dados a vari\u00e1veis, fun\u00e7\u00f5es, classes, etc. No exemplo, result \u00e9 um identificador. Operadores: S\u00e3o s\u00edmbolos que representam opera\u00e7\u00f5es. No exemplo, = , + , * , e - s\u00e3o operadores. Literais: S\u00e3o valores constantes diretamente representados no c\u00f3digo. No exemplo, 3 , 5 , 2 , e 8 s\u00e3o literais inteiros. Delimitadores: S\u00e3o caracteres que delimitam estruturas de c\u00f3digo. No exemplo, ( , ) , e ; s\u00e3o delimitadores.","title":"Explica\u00e7\u00e3o Detalhada"},{"location":"aula2/#implementacao-do-analisador-lexico-em-python","text":"Agora, vamos implementar um analisador l\u00e9xico simples em Python para gerar os tokens a partir do c\u00f3digo-fonte acima. import re def tokenize(code): # Defini\u00e7\u00e3o das express\u00f5es regulares para cada tipo de token token_specs = [ ('KEYWORD', r'if|then|else|end|print'), ('IDENTIFIER', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('NUMBER', r'\\d+(\\.\\d+)?'), ('OPERATOR', r'[><=!+\\-*/%]'), ('STRING', r'\".*?\"'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('NEWLINE', r'\\n'), ('SKIP', r'[ \\t]+'), ] # Compila\u00e7\u00e3o das express\u00f5es regulares token_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs) regex = re.compile(token_regex) # Gera\u00e7\u00e3o dos tokens tokens = [] for match in regex.finditer(code): token_type = match.lastgroup token_value = match.group(token_type) if token_type != 'SKIP': tokens.append((token_type, token_value)) return tokens # C\u00f3digo-fonte de exemplo code = ''' if x > 10 then print(\"Hello, World!\") else print(\"x is less than or equal to 10\") end ''' # Chamada da fun\u00e7\u00e3o de tokeniza\u00e7\u00e3o tokens = tokenize(code) # Impress\u00e3o dos tokens gerados for token in tokens: print(token) Neste exemplo, utilizamos express\u00f5es regulares para definir os padr\u00f5es de cada tipo de token. Em seguida, compilamos essas express\u00f5es regulares em um \u00fanico padr\u00e3o usando o m\u00f3dulo re do Python. A fun\u00e7\u00e3o tokenize recebe o c\u00f3digo-fonte como entrada e itera sobre as correspond\u00eancias encontradas pelo padr\u00e3o de express\u00e3o regular. Para cada correspond\u00eancia, extra\u00edmos o tipo de token e seu valor. Ignoramos os tokens do tipo SKIP , que representam espa\u00e7os em branco e tabula\u00e7\u00f5es. Por fim, imprimimos os tokens gerados, que ser\u00e3o semelhantes a: ('KEYWORD', 'if') ('IDENTIFIER', 'x') ('OPERATOR', '>') ('NUMBER', '10') ('KEYWORD', 'then') ('KEYWORD', 'print') ('LPAREN', '(') ('STRING', '\"Hello, World!\"') ('RPAREN', ')') ('KEYWORD', 'else') ('KEYWORD', 'print') ('LPAREN', '(') ('STRING', '\"x is less than or equal to 10\"') ('RPAREN', ')') ('KEYWORD', 'end') Cada token \u00e9 representado por uma tupla contendo o tipo de token e seu valor correspondente.","title":"Implementa\u00e7\u00e3o do Analisador L\u00e9xico em Python \ud83d\udc0d"},{"location":"aula2/#vamos-brincar-no-colab","text":"Claro! Vamos refazer o exemplo anterior e criar uma tabela de s\u00edmbolos usando o pandas no Google Colab. Aqui est\u00e1 o c\u00f3digo atualizado: import re import pandas as pd def tokenize(code): # Defini\u00e7\u00e3o das express\u00f5es regulares para cada tipo de token token_specs = [ ('KEYWORD', r'if|then|else|end|print'), ('IDENTIFIER', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('NUMBER', r'\\d+(\\.\\d+)?'), ('OPERATOR', r'[><=!+\\-*/%]'), ('STRING', r'\".*?\"'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('NEWLINE', r'\\n'), ('SKIP', r'[ \\t]+'), ] # Compila\u00e7\u00e3o das express\u00f5es regulares token_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs) regex = re.compile(token_regex) # Gera\u00e7\u00e3o dos tokens tokens = [] for match in regex.finditer(code): token_type = match.lastgroup token_value = match.group(token_type) if token_type != 'SKIP': tokens.append((token_type, token_value)) return tokens # C\u00f3digo-fonte de exemplo code = ''' if x > 10 then print(\"Hello, World!\") else print(\"x is less than or equal to 10\") end ''' # Chamada da fun\u00e7\u00e3o de tokeniza\u00e7\u00e3o tokens = tokenize(code) # Cria\u00e7\u00e3o da tabela de s\u00edmbolos usando o pandas symbol_table = pd.DataFrame(tokens, columns=['Token Type', 'Token Value']) # Impress\u00e3o da tabela de s\u00edmbolos print(\"Tabela de S\u00edmbolos:\") print(symbol_table) Neste exemplo atualizado, utilizamos o pandas para criar uma tabela de s\u00edmbolos a partir dos tokens gerados. Ap\u00f3s chamar a fun\u00e7\u00e3o tokenize com o c\u00f3digo-fonte de exemplo, criamos um DataFrame do pandas chamado symbol_table usando os tokens como dados e especificando as colunas como \"Token Type\" e \"Token Value\". Por fim, imprimimos a tabela de s\u00edmbolos usando o m\u00e9todo print . Ao executar este c\u00f3digo no Google Colab, voc\u00ea ver\u00e1 a seguinte sa\u00edda: Tabela de S\u00edmbolos: Token Type Token Value 0 KEYWORD if 1 IDENTIFIER x 2 OPERATOR > 3 NUMBER 10 4 KEYWORD then 5 KEYWORD print 6 LPAREN ( 7 STRING \"Hello, World!\" 8 RPAREN ) 9 KEYWORD else 10 KEYWORD print 11 LPAREN ( 12 STRING \"x is less than or equal to 10\" 13 RPAREN ) 14 KEYWORD end A tabela de s\u00edmbolos exibe cada token encontrado no c\u00f3digo-fonte, juntamente com seu tipo de token correspondente.","title":"Vamos Brincar no Colab!"},{"location":"aula2/#conclusao","text":"Compila\u00e7\u00e3o e interpreta\u00e7\u00e3o s\u00e3o duas abordagens distintas para processar o c\u00f3digo-fonte e execut\u00e1-lo em um computador. Enquanto a compila\u00e7\u00e3o oferece maior velocidade de execu\u00e7\u00e3o e menor consumo de recursos, a interpreta\u00e7\u00e3o proporciona maior flexibilidade e portabilidade. A escolha entre essas abordagens depende dos requisitos espec\u00edficos do projeto, levando em considera\u00e7\u00e3o fatores como desempenho, consumo de energia e facilidade de desenvolvimento. Ao compreender as diferen\u00e7as entre compila\u00e7\u00e3o e interpreta\u00e7\u00e3o, os programadores podem tomar decis\u00f5es informadas sobre qual abordagem adotar para seus projetos, buscando o equil\u00edbrio ideal entre efici\u00eancia e produtividade. \ud83d\ude80","title":"Conclus\u00e3o \ud83c\udf89"},{"location":"aula2/#indicacao-de-livros","text":"Link: Programa\u00e7\u00e3o Funcional e Concorrente em Rust Link: ASP.NET Core MVC","title":"Indica\u00e7\u00e3o de Livros:"},{"location":"aula3/","text":"An\u00e1lise L\u00e9xica Introdu\u00e7\u00e3o A an\u00e1lise l\u00e9xica, tamb\u00e9m conhecida como lexing ou tokeniza\u00e7\u00e3o, \u00e9 o primeiro est\u00e1gio na compila\u00e7\u00e3o de um programa. Esse processo envolve a convers\u00e3o de uma sequ\u00eancia de caracteres de entrada em uma sequ\u00eancia de tokens, que s\u00e3o unidades at\u00f4micas significativas do c\u00f3digo fonte. Esses tokens podem representar palavras-chave, identificadores, literais, operadores e outros elementos sint\u00e1ticos. Objetivos da An\u00e1lise L\u00e9xica Os principais objetivos da an\u00e1lise l\u00e9xica incluem: Simplifica\u00e7\u00e3o da an\u00e1lise sint\u00e1tica : Convertendo a entrada em tokens, a an\u00e1lise sint\u00e1tica (ou parsing) torna-se mais simples e eficiente. Detec\u00e7\u00e3o de erros l\u00e9xicos : Identificar e relatar erros na fase inicial da compila\u00e7\u00e3o. Remo\u00e7\u00e3o de elementos irrelevantes : Eliminar espa\u00e7os em branco, coment\u00e1rios e outros elementos que n\u00e3o afetam a execu\u00e7\u00e3o do c\u00f3digo. Componentes de um Analisador L\u00e9xico Um analisador l\u00e9xico geralmente \u00e9 composto por: Tabela de s\u00edmbolos : Armazena informa\u00e7\u00f5es sobre identificadores e palavras-chave encontradas no c\u00f3digo. Regras l\u00e9xicas : Definem padr\u00f5es para reconhecer tokens utilizando express\u00f5es regulares. Aut\u00f4matos Finitos : Implementam as regras l\u00e9xicas para varrer a entrada e produzir tokens. Processo de An\u00e1lise L\u00e9xica Leitura da entrada : O c\u00f3digo fonte \u00e9 lido como uma sequ\u00eancia de caracteres. Aplica\u00e7\u00e3o de regras l\u00e9xicas : Padr\u00f5es s\u00e3o aplicados para identificar diferentes tipos de tokens. Gera\u00e7\u00e3o de tokens : Cada padr\u00e3o identificado \u00e9 convertido em um token correspondente. Tratamento de erros : Se um padr\u00e3o inv\u00e1lido \u00e9 encontrado, um erro l\u00e9xico \u00e9 reportado. Exemplo de Tokens Considere o seguinte trecho de c\u00f3digo: int main() { int a = 10; int b = 20; int sum = a + b; } O analisador l\u00e9xico pode gerar a seguinte sequ\u00eancia de tokens: int (palavra-chave) main (identificador) ( (s\u00edmbolo) ) (s\u00edmbolo) { (s\u00edmbolo) int (palavra-chave) a (identificador) = (operador) 10 (literal) ; (s\u00edmbolo) int (palavra-chave) b (identificador) = (operador) 20 (literal) ; (s\u00edmbolo) int (palavra-chave) sum (identificador) = (operador) a (identificador) + (operador) b (identificador) ; (s\u00edmbolo) } (s\u00edmbolo) Desafio em Python Agora que voc\u00ea compreendeu o b\u00e1sico sobre an\u00e1lise l\u00e9xica, aqui est\u00e1 um desafio para colocar em pr\u00e1tica seus conhecimentos. Desafio: Implementar um Analisador L\u00e9xico em Python Escreva um analisador l\u00e9xico em Python que reconhe\u00e7a os seguintes tokens em uma express\u00e3o aritm\u00e9tica simples contendo inteiros, operadores ( + , - , * , / ) e par\u00eanteses: Inteiros: uma sequ\u00eancia de d\u00edgitos. Operadores: + , - , * , / Par\u00eanteses: ( , ) Sua tarefa \u00e9 implementar a fun\u00e7\u00e3o lexical_analysis que recebe uma string contendo a express\u00e3o aritm\u00e9tica e retorna uma lista de tokens. import re def lexical_analysis(expression): # Definir os padr\u00f5es para os tokens token_specification = [ ('NUMBER', r'\\d+'), # Inteiros ('PLUS', r'\\+'), # Operador + ('MINUS', r'-'), # Operador - ('TIMES', r'\\*'), # Operador * ('DIVIDE', r'/'), # Operador / ('LPAREN', r'\\('), # Par\u00eantese esquerdo ('RPAREN', r'\\)'), # Par\u00eantese direito ('SKIP', r'[ \\t]+'), # Espa\u00e7os em branco ('MISMATCH', r'.'), # Qualquer outro caractere ] # Compilar as express\u00f5es regulares em um \u00fanico regex tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_specification) get_token = re.compile(tok_regex).match line = expression.strip() pos = 0 tokens = [] # Iterar sobre a string de entrada para encontrar os tokens while pos < len(line): match = get_token(line, pos) if match is None: raise RuntimeError(f'Erro l\u00e9xico em {line[pos]}') pos = match.end() token_type = match.lastgroup if token_type == 'NUMBER': value = int(match.group(token_type)) tokens.append((token_type, value)) elif token_type != 'SKIP': tokens.append((token_type, match.group(token_type))) return tokens # Teste seu analisador l\u00e9xico expression = \"3 + 5 * ( 10 - 20 ) / 2\" tokens = lexical_analysis(expression) print(tokens) Teste esperado Para a express\u00e3o \"3 + 5 * ( 10 - 20 ) / 2\" , a sa\u00edda esperada seria: [('NUMBER', 3), ('PLUS', '+'), ('NUMBER', 5), ('TIMES', '*'), ('LPAREN', '('), ('NUMBER', 10), ('MINUS', '-'), ('NUMBER', 20), ('RPAREN', ')'), ('DIVIDE', '/'), ('NUMBER', 2)] Boa sorte e divirta-se resolvendo o desafio! An\u00e1lise Sint\u00e1tica Introdu\u00e7\u00e3o A an\u00e1lise sint\u00e1tica, tamb\u00e9m conhecida como parsing, \u00e9 o segundo est\u00e1gio do processo de compila\u00e7\u00e3o. Ela envolve a an\u00e1lise da sequ\u00eancia de tokens gerada pelo analisador l\u00e9xico para construir uma estrutura hier\u00e1rquica, como uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). Essa \u00e1rvore representa a estrutura gramatical do c\u00f3digo fonte conforme definido pela gram\u00e1tica da linguagem de programa\u00e7\u00e3o. Objetivos da An\u00e1lise Sint\u00e1tica Os principais objetivos da an\u00e1lise sint\u00e1tica incluem: Verifica\u00e7\u00e3o da estrutura gramatical : Garantir que a sequ\u00eancia de tokens obede\u00e7a \u00e0s regras gramaticais da linguagem. Constru\u00e7\u00e3o de estruturas hier\u00e1rquicas : Criar representa\u00e7\u00f5es estruturais do c\u00f3digo, como \u00e1rvores de an\u00e1lise ou grafos. Detec\u00e7\u00e3o de erros sint\u00e1ticos : Identificar e relatar erros gramaticais. Componentes de um Analisador Sint\u00e1tico Um analisador sint\u00e1tico geralmente \u00e9 composto por: Gram\u00e1tica da linguagem : Um conjunto de regras que define a estrutura da linguagem. Analisador l\u00e9xico : Um componente que fornece a sequ\u00eancia de tokens. Algoritmo de parsing : Respons\u00e1vel por construir a \u00e1rvore de an\u00e1lise a partir dos tokens. Processo de An\u00e1lise Sint\u00e1tica Recebimento dos tokens : A sequ\u00eancia de tokens gerada pelo analisador l\u00e9xico \u00e9 recebida. Aplica\u00e7\u00e3o de regras gramaticais : As regras gramaticais s\u00e3o aplicadas para construir a \u00e1rvore de an\u00e1lise. Detec\u00e7\u00e3o de erros sint\u00e1ticos : Erros s\u00e3o detectados e reportados se a sequ\u00eancia de tokens n\u00e3o obedecer \u00e0s regras gramaticais. Exemplos de Gram\u00e1ticas Considere a seguinte gram\u00e1tica para express\u00f5es aritm\u00e9ticas simples: Express\u00e3o \u2192 Termo {(\"+\" | \"-\") Termo} Termo \u2192 Fator {(\"*\" | \"/\") Fator} Fator \u2192 N\u00famero | \"(\" Express\u00e3o \")\" Exemplo de Implementa\u00e7\u00e3o Abaixo est\u00e1 uma implementa\u00e7\u00e3o b\u00e1sica de um analisador sint\u00e1tico para express\u00f5es aritm\u00e9ticas em Python. Ele utiliza um analisador l\u00e9xico para gerar tokens e, em seguida, constr\u00f3i uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST). import re # Analisador L\u00e9xico def lexical_analysis(expression): token_specification = [ ('NUMBER', r'\\d+'), ('PLUS', r'\\+'), ('MINUS', r'-'), ('TIMES', r'\\*'), ('DIVIDE', r'/'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('SKIP', r'[ \\t]+'), ('MISMATCH', r'.'), ] tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_specification) get_token = re.compile(tok_regex).match line = expression.strip() pos = 0 tokens = [] while pos < len(line): match = get_token(line, pos) if match is None: raise RuntimeError(f'Erro l\u00e9xico em {line[pos]}') pos = match.end() token_type = match.lastgroup if token_type == 'NUMBER': value = int(match.group(token_type)) tokens.append((token_type, value)) elif token_type != 'SKIP': tokens.append((token_type, match.group(token_type))) return tokens # Analisador Sint\u00e1tico class Parser: def __init__(self, tokens): self.tokens = tokens self.pos = 0 def parse(self): return self.expression() def expression(self): node = self.term() while self.current_token() in ('PLUS', 'MINUS'): token = self.current_token() self.next_token() node = (token, node, self.term()) return node def term(self): node = self.factor() while self.current_token() in ('TIMES', 'DIVIDE'): token = self.current_token() self.next_token() node = (token, node, self.factor()) return node def factor(self): token = self.current_token() if token == 'NUMBER': self.next_token() return ('NUMBER', self.current_value()) elif token == 'LPAREN': self.next_token() node = self.expression() if self.current_token() == 'RPAREN': self.next_token() return node else: raise RuntimeError(\"Erro: ')' esperado\") else: raise RuntimeError(f\"Erro: Token inesperado {token}\") def current_token(self): return self.tokens[self.pos][0] if self.pos < len(self.tokens) else None def current_value(self): return self.tokens[self.pos - 1][1] def next_token(self): self.pos += 1 # Fun\u00e7\u00e3o principal para realizar a an\u00e1lise l\u00e9xica e sint\u00e1tica def main(): expression = \"3 + 5 * ( 10 - 20 ) / 2\" tokens = lexical_analysis(expression) print(\"Tokens:\", tokens) parser = Parser(tokens) ast = parser.parse() print(\"AST:\", ast) # Executar a fun\u00e7\u00e3o principal if __name__ == \"__main__\": main() Desafio em Python Agora que voc\u00ea compreendeu o b\u00e1sico sobre an\u00e1lise sint\u00e1tica, aqui est\u00e1 um desafio para colocar em pr\u00e1tica seus conhecimentos. Desafio: Implementar um Analisador Sint\u00e1tico Completo Escreva um analisador sint\u00e1tico que, al\u00e9m de analisar express\u00f5es aritm\u00e9ticas simples, seja capaz de analisar express\u00f5es com vari\u00e1veis. Considere a seguinte gram\u00e1tica estendida: Express\u00e3o \u2192 Termo {(\"+\" | \"-\") Termo} Termo \u2192 Fator {(\"*\" | \"/\") Fator} Fator \u2192 N\u00famero | Identificador | \"(\" Express\u00e3o \")\" Identificador \u2192 [a-zA-Z_][a-zA-Z0-9_]* Implemente a fun\u00e7\u00e3o parse para lidar com vari\u00e1veis e teste-a com uma express\u00e3o que inclua vari\u00e1veis. import re def lexical_analysis(expression): token_specification = [ ('NUMBER', r'\\d+'), ('ID', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('PLUS', r'\\+'), ('MINUS', r'-'), ('TIMES', r'\\*'), ('DIVIDE', r'/'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('SKIP', r'[ \\t]+'), ('MISMATCH', r'.'), ] tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_specification) get_token = re.compile(tok_regex).match line = expression.strip() pos = 0 tokens = [] while pos < len(line): match = get_token(line, pos) if match is None: raise RuntimeError(f'Erro l\u00e9xico em {line[pos]}') pos = match.end() token_type = match.lastgroup if token_type in ('NUMBER', 'ID'): value = match.group(token_type) tokens.append((token_type, value)) elif token_type != 'SKIP': tokens.append((token_type, match.group(token_type))) return tokens class Parser: def __init__(self, tokens): self.tokens = tokens self.pos = 0 def parse(self): return self.expression() def expression(self): node = self.term() while self.current_token() in ('PLUS', 'MINUS'): token = self.current_token() self.next_token() node = (token, node, self.term()) return node def term(self): node = self.factor() while self.current_token() in ('TIMES', 'DIVIDE'): token = self.current_token() self.next_token() node = (token, node, self.factor()) return node def factor(self): token = self.current_token() if token == 'NUMBER': self.next_token() return ('NUMBER', self.current_value()) elif token == 'ID': self.next_token() return ('ID', self.current_value()) elif token == 'LPAREN': self.next_token() node = self.expression() if self.current_token() == 'RPAREN': self.next_token() return node else: raise RuntimeError(\"Erro: ')' esperado\") else: raise RuntimeError(f\"Erro: Token inesperado {token}\") def current_token(self): return self.tokens[self.pos][0] if self.pos < len(self.tokens) else None def current_value(self): return self.tokens[self.pos - 1][1] def next_token(self): self.pos += 1 def main(): expression = \"x + 3 * ( y - 2 ) / z\" tokens = lexical_analysis(expression) print(\"Tokens:\", tokens) parser = Parser(tokens) ast = parser.parse() print(\"AST:\", ast) if __name__ == \"__main__\": main() Teste esperado Para a express\u00e3o \"x + 3 * ( y - 2 ) / z\" , a sa\u00edda esperada seria: Tokens: [('ID', 'x'), ('PLUS', '+'), ('NUMBER', '3'), ('TIMES', '*'), ('LPAREN', '('), ('ID', 'y'), ('MINUS', '-'), ('NUMBER', '2'), ('RPAREN', ')'), ('DIVIDE', '/'), ('ID', 'z')] AST: ('PLUS', ('ID', 'x'), ('DIVIDE', ('TIMES', ('NUMBER', '3'), ('MINUS', ('ID', 'y'), ('NUMBER', '2'))), ('ID', 'z'))) Boa sorte e divirta-se resolvendo o desafio! Resum\u00e3o! An\u00e1lise de Compila\u00e7\u00e3o: L\u00e9xica, Sint\u00e1tica e Sem\u00e2ntica Introdu\u00e7\u00e3o O processo de compila\u00e7\u00e3o de um programa pode ser dividido em v\u00e1rias fases distintas. Cada fase tem um papel crucial na transforma\u00e7\u00e3o do c\u00f3digo fonte em c\u00f3digo execut\u00e1vel. As tr\u00eas principais fases s\u00e3o a an\u00e1lise l\u00e9xica, a an\u00e1lise sint\u00e1tica e a an\u00e1lise sem\u00e2ntica. An\u00e1lise L\u00e9xica Objetivo A an\u00e1lise l\u00e9xica, tamb\u00e9m conhecida como lexing ou tokeniza\u00e7\u00e3o, \u00e9 a primeira etapa do processo de compila\u00e7\u00e3o. Seu objetivo \u00e9 converter a sequ\u00eancia de caracteres do c\u00f3digo fonte em uma sequ\u00eancia de tokens, que s\u00e3o as menores unidades significativas do c\u00f3digo. Componentes Tabela de s\u00edmbolos : Armazena informa\u00e7\u00f5es sobre identificadores e palavras-chave. Regras l\u00e9xicas : Definem padr\u00f5es para reconhecer tokens usando express\u00f5es regulares. Aut\u00f4matos Finitos : Implementam as regras l\u00e9xicas para varrer a entrada e produzir tokens. Exemplo de Tokens Para o c\u00f3digo int a = 10; , os tokens podem ser: int , a , = , 10 , ; . Implementa\u00e7\u00e3o import re def lexical_analysis(expression): token_specification = [ ('NUMBER', r'\\d+'), ('ID', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('PLUS', r'\\+'), ('MINUS', r'-'), ('TIMES', r'\\*'), ('DIVIDE', r'/'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('SKIP', r'[ \\t]+'), ('MISMATCH', r'.'), ] tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_specification) get_token = re.compile(tok_regex).match line = expression.strip() pos = 0 tokens = [] while pos < len(line): match = get_token(line, pos) if match is None: raise RuntimeError(f'Erro l\u00e9xico em {line[pos]}') pos = match.end() token_type = match.lastgroup if token_type in ('NUMBER', 'ID'): value = match.group(token_type) tokens.append((token_type, value)) elif token_type != 'SKIP': tokens.append((token_type, match.group(token_type))) return tokens An\u00e1lise Sint\u00e1tica Objetivo A an\u00e1lise sint\u00e1tica, ou parsing, \u00e9 a segunda etapa do processo de compila\u00e7\u00e3o. Seu objetivo \u00e9 analisar a sequ\u00eancia de tokens para construir uma estrutura hier\u00e1rquica, como uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST), que representa a estrutura gramatical do c\u00f3digo. Componentes Gram\u00e1tica da linguagem : Conjunto de regras que define a estrutura da linguagem. Analisador l\u00e9xico : Componente que fornece a sequ\u00eancia de tokens. Algoritmo de parsing : Constr\u00f3i a \u00e1rvore de an\u00e1lise a partir dos tokens. Exemplo de Gram\u00e1tica Para express\u00f5es aritm\u00e9ticas simples: - Express\u00e3o \u2192 Termo {(\"+\" | \"-\") Termo} - Termo \u2192 Fator {(\"*\" | \"/\") Fator} - Fator \u2192 N\u00famero | Identificador | \"(\" Express\u00e3o \")\" Implementa\u00e7\u00e3o class Parser: def __init__(self, tokens): self.tokens = tokens self.pos = 0 def parse(self): return self.expression() def expression(self): node = self.term() while self.current_token() in ('PLUS', 'MINUS'): token = self.current_token() self.next_token() node = (token, node, self.term()) return node def term(self): node = self.factor() while self.current_token() in ('TIMES', 'DIVIDE'): token = self.current_token() self.next_token() node = (token, node, self.factor()) return node def factor(self): token = self.current_token() if token == 'NUMBER': self.next_token() return ('NUMBER', self.current_value()) elif token == 'ID': self.next_token() return ('ID', self.current_value()) elif token == 'LPAREN': self.next_token() node = self.expression() if self.current_token() == 'RPAREN': self.next_token() return node else: raise RuntimeError(\"Erro: ')' esperado\") else: raise RuntimeError(f\"Erro: Token inesperado {token}\") def current_token(self): return self.tokens[self.pos][0] if self.pos < len(self.tokens) else None def current_value(self): return self.tokens[self.pos - 1][1] def next_token(self): self.pos += 1 # Fun\u00e7\u00e3o principal para realizar a an\u00e1lise l\u00e9xica e sint\u00e1tica def main(): expression = \"x + 3 * ( y - 2 ) / z\" tokens = lexical_analysis(expression) print(\"Tokens:\", tokens) parser = Parser(tokens) ast = parser.parse() print(\"AST:\", ast) if __name__ == \"__main__\": main() An\u00e1lise Sem\u00e2ntica Objetivo A an\u00e1lise sem\u00e2ntica \u00e9 a terceira etapa do processo de compila\u00e7\u00e3o. Seu objetivo \u00e9 verificar a corre\u00e7\u00e3o sem\u00e2ntica do programa, assegurando que ele faz sentido dentro do contexto da linguagem. Isso inclui verifica\u00e7\u00e3o de tipos, escopo de vari\u00e1veis e outras regras sem\u00e2nticas. Componentes Tabela de s\u00edmbolos : Armazena informa\u00e7\u00f5es sobre identificadores, seus tipos e escopos. Regras sem\u00e2nticas : Definem as verifica\u00e7\u00f5es necess\u00e1rias para garantir a corre\u00e7\u00e3o sem\u00e2ntica do c\u00f3digo. Processo Verifica\u00e7\u00e3o de tipos : Assegurar que as opera\u00e7\u00f5es s\u00e3o realizadas entre tipos compat\u00edveis. Resolu\u00e7\u00e3o de identificadores : Garantir que todas as vari\u00e1veis e fun\u00e7\u00f5es est\u00e3o declaradas antes de serem usadas. An\u00e1lise de escopo : Verificar que as vari\u00e1veis est\u00e3o acess\u00edveis apenas dentro do seu escopo. Exemplo de Verifica\u00e7\u00e3o de Tipos Para a express\u00e3o x + 3 , onde x \u00e9 uma vari\u00e1vel do tipo int : class SemanticAnalyzer: def __init__(self, ast, symbol_table): self.ast = ast self.symbol_table = symbol_table def analyze(self): return self._analyze_node(self.ast) def _analyze_node(self, node): if isinstance(node, tuple): op = node[0] left = self._analyze_node(node[1]) right = self._analyze_node(node[2]) if op in ('PLUS', 'MINUS', 'TIMES', 'DIVIDE'): if left != 'int' or right != 'int': raise RuntimeError(f\"Erro sem\u00e2ntico: opera\u00e7\u00e3o {op} inv\u00e1lida entre {left} e {right}\") return 'int' elif node[0] == 'NUMBER': return 'int' elif node[0] == 'ID': identifier = node[1] if identifier not in self.symbol_table: raise RuntimeError(f\"Erro sem\u00e2ntico: vari\u00e1vel {identifier} n\u00e3o declarada\") return self.symbol_table[identifier] else: raise RuntimeError(f\"Erro sem\u00e2ntico: n\u00f3 inv\u00e1lido {node}\") # Fun\u00e7\u00e3o principal para realizar a an\u00e1lise sem\u00e2ntica def main(): expression = \"x + 3 * ( y - 2 ) / z\" tokens = lexical_analysis(expression) print(\"Tokens:\", tokens) parser = Parser(tokens) ast = parser.parse() print(\"AST:\", ast) symbol_table = {'x': 'int', 'y': 'int', 'z': 'int'} analyzer = SemanticAnalyzer(ast, symbol_table) analyzer.analyze() print(\"An\u00e1lise sem\u00e2ntica conclu\u00edda com sucesso\") if __name__ == \"__main__\": main() Conclus\u00e3o A an\u00e1lise l\u00e9xica, sint\u00e1tica e sem\u00e2ntica s\u00e3o etapas fundamentais do processo de compila\u00e7\u00e3o, cada uma desempenhando um papel crucial na transforma\u00e7\u00e3o do c\u00f3digo fonte em um programa execut\u00e1vel. A an\u00e1lise l\u00e9xica converte o c\u00f3digo em tokens, a an\u00e1lise sint\u00e1tica constr\u00f3i a estrutura gramatical e a an\u00e1lise sem\u00e2ntica verifica a corre\u00e7\u00e3o contextual do programa. Compreender essas etapas \u00e9 essencial para o desenvolvimento de compiladores e int\u00e9rpretes eficientes.","title":"Aula 3"},{"location":"aula3/#analise-lexica","text":"","title":"An\u00e1lise L\u00e9xica"},{"location":"aula3/#introducao","text":"A an\u00e1lise l\u00e9xica, tamb\u00e9m conhecida como lexing ou tokeniza\u00e7\u00e3o, \u00e9 o primeiro est\u00e1gio na compila\u00e7\u00e3o de um programa. Esse processo envolve a convers\u00e3o de uma sequ\u00eancia de caracteres de entrada em uma sequ\u00eancia de tokens, que s\u00e3o unidades at\u00f4micas significativas do c\u00f3digo fonte. Esses tokens podem representar palavras-chave, identificadores, literais, operadores e outros elementos sint\u00e1ticos.","title":"Introdu\u00e7\u00e3o"},{"location":"aula3/#objetivos-da-analise-lexica","text":"Os principais objetivos da an\u00e1lise l\u00e9xica incluem: Simplifica\u00e7\u00e3o da an\u00e1lise sint\u00e1tica : Convertendo a entrada em tokens, a an\u00e1lise sint\u00e1tica (ou parsing) torna-se mais simples e eficiente. Detec\u00e7\u00e3o de erros l\u00e9xicos : Identificar e relatar erros na fase inicial da compila\u00e7\u00e3o. Remo\u00e7\u00e3o de elementos irrelevantes : Eliminar espa\u00e7os em branco, coment\u00e1rios e outros elementos que n\u00e3o afetam a execu\u00e7\u00e3o do c\u00f3digo.","title":"Objetivos da An\u00e1lise L\u00e9xica"},{"location":"aula3/#componentes-de-um-analisador-lexico","text":"Um analisador l\u00e9xico geralmente \u00e9 composto por: Tabela de s\u00edmbolos : Armazena informa\u00e7\u00f5es sobre identificadores e palavras-chave encontradas no c\u00f3digo. Regras l\u00e9xicas : Definem padr\u00f5es para reconhecer tokens utilizando express\u00f5es regulares. Aut\u00f4matos Finitos : Implementam as regras l\u00e9xicas para varrer a entrada e produzir tokens.","title":"Componentes de um Analisador L\u00e9xico"},{"location":"aula3/#processo-de-analise-lexica","text":"Leitura da entrada : O c\u00f3digo fonte \u00e9 lido como uma sequ\u00eancia de caracteres. Aplica\u00e7\u00e3o de regras l\u00e9xicas : Padr\u00f5es s\u00e3o aplicados para identificar diferentes tipos de tokens. Gera\u00e7\u00e3o de tokens : Cada padr\u00e3o identificado \u00e9 convertido em um token correspondente. Tratamento de erros : Se um padr\u00e3o inv\u00e1lido \u00e9 encontrado, um erro l\u00e9xico \u00e9 reportado.","title":"Processo de An\u00e1lise L\u00e9xica"},{"location":"aula3/#exemplo-de-tokens","text":"Considere o seguinte trecho de c\u00f3digo: int main() { int a = 10; int b = 20; int sum = a + b; } O analisador l\u00e9xico pode gerar a seguinte sequ\u00eancia de tokens: int (palavra-chave) main (identificador) ( (s\u00edmbolo) ) (s\u00edmbolo) { (s\u00edmbolo) int (palavra-chave) a (identificador) = (operador) 10 (literal) ; (s\u00edmbolo) int (palavra-chave) b (identificador) = (operador) 20 (literal) ; (s\u00edmbolo) int (palavra-chave) sum (identificador) = (operador) a (identificador) + (operador) b (identificador) ; (s\u00edmbolo) } (s\u00edmbolo)","title":"Exemplo de Tokens"},{"location":"aula3/#desafio-em-python","text":"Agora que voc\u00ea compreendeu o b\u00e1sico sobre an\u00e1lise l\u00e9xica, aqui est\u00e1 um desafio para colocar em pr\u00e1tica seus conhecimentos.","title":"Desafio em Python"},{"location":"aula3/#desafio-implementar-um-analisador-lexico-em-python","text":"Escreva um analisador l\u00e9xico em Python que reconhe\u00e7a os seguintes tokens em uma express\u00e3o aritm\u00e9tica simples contendo inteiros, operadores ( + , - , * , / ) e par\u00eanteses: Inteiros: uma sequ\u00eancia de d\u00edgitos. Operadores: + , - , * , / Par\u00eanteses: ( , ) Sua tarefa \u00e9 implementar a fun\u00e7\u00e3o lexical_analysis que recebe uma string contendo a express\u00e3o aritm\u00e9tica e retorna uma lista de tokens. import re def lexical_analysis(expression): # Definir os padr\u00f5es para os tokens token_specification = [ ('NUMBER', r'\\d+'), # Inteiros ('PLUS', r'\\+'), # Operador + ('MINUS', r'-'), # Operador - ('TIMES', r'\\*'), # Operador * ('DIVIDE', r'/'), # Operador / ('LPAREN', r'\\('), # Par\u00eantese esquerdo ('RPAREN', r'\\)'), # Par\u00eantese direito ('SKIP', r'[ \\t]+'), # Espa\u00e7os em branco ('MISMATCH', r'.'), # Qualquer outro caractere ] # Compilar as express\u00f5es regulares em um \u00fanico regex tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_specification) get_token = re.compile(tok_regex).match line = expression.strip() pos = 0 tokens = [] # Iterar sobre a string de entrada para encontrar os tokens while pos < len(line): match = get_token(line, pos) if match is None: raise RuntimeError(f'Erro l\u00e9xico em {line[pos]}') pos = match.end() token_type = match.lastgroup if token_type == 'NUMBER': value = int(match.group(token_type)) tokens.append((token_type, value)) elif token_type != 'SKIP': tokens.append((token_type, match.group(token_type))) return tokens # Teste seu analisador l\u00e9xico expression = \"3 + 5 * ( 10 - 20 ) / 2\" tokens = lexical_analysis(expression) print(tokens)","title":"Desafio: Implementar um Analisador L\u00e9xico em Python"},{"location":"aula3/#teste-esperado","text":"Para a express\u00e3o \"3 + 5 * ( 10 - 20 ) / 2\" , a sa\u00edda esperada seria: [('NUMBER', 3), ('PLUS', '+'), ('NUMBER', 5), ('TIMES', '*'), ('LPAREN', '('), ('NUMBER', 10), ('MINUS', '-'), ('NUMBER', 20), ('RPAREN', ')'), ('DIVIDE', '/'), ('NUMBER', 2)] Boa sorte e divirta-se resolvendo o desafio!","title":"Teste esperado"},{"location":"aula3/#analise-sintatica","text":"","title":"An\u00e1lise Sint\u00e1tica"},{"location":"aula3/#introducao_1","text":"A an\u00e1lise sint\u00e1tica, tamb\u00e9m conhecida como parsing, \u00e9 o segundo est\u00e1gio do processo de compila\u00e7\u00e3o. Ela envolve a an\u00e1lise da sequ\u00eancia de tokens gerada pelo analisador l\u00e9xico para construir uma estrutura hier\u00e1rquica, como uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). Essa \u00e1rvore representa a estrutura gramatical do c\u00f3digo fonte conforme definido pela gram\u00e1tica da linguagem de programa\u00e7\u00e3o.","title":"Introdu\u00e7\u00e3o"},{"location":"aula3/#objetivos-da-analise-sintatica","text":"Os principais objetivos da an\u00e1lise sint\u00e1tica incluem: Verifica\u00e7\u00e3o da estrutura gramatical : Garantir que a sequ\u00eancia de tokens obede\u00e7a \u00e0s regras gramaticais da linguagem. Constru\u00e7\u00e3o de estruturas hier\u00e1rquicas : Criar representa\u00e7\u00f5es estruturais do c\u00f3digo, como \u00e1rvores de an\u00e1lise ou grafos. Detec\u00e7\u00e3o de erros sint\u00e1ticos : Identificar e relatar erros gramaticais.","title":"Objetivos da An\u00e1lise Sint\u00e1tica"},{"location":"aula3/#componentes-de-um-analisador-sintatico","text":"Um analisador sint\u00e1tico geralmente \u00e9 composto por: Gram\u00e1tica da linguagem : Um conjunto de regras que define a estrutura da linguagem. Analisador l\u00e9xico : Um componente que fornece a sequ\u00eancia de tokens. Algoritmo de parsing : Respons\u00e1vel por construir a \u00e1rvore de an\u00e1lise a partir dos tokens.","title":"Componentes de um Analisador Sint\u00e1tico"},{"location":"aula3/#processo-de-analise-sintatica","text":"Recebimento dos tokens : A sequ\u00eancia de tokens gerada pelo analisador l\u00e9xico \u00e9 recebida. Aplica\u00e7\u00e3o de regras gramaticais : As regras gramaticais s\u00e3o aplicadas para construir a \u00e1rvore de an\u00e1lise. Detec\u00e7\u00e3o de erros sint\u00e1ticos : Erros s\u00e3o detectados e reportados se a sequ\u00eancia de tokens n\u00e3o obedecer \u00e0s regras gramaticais.","title":"Processo de An\u00e1lise Sint\u00e1tica"},{"location":"aula3/#exemplos-de-gramaticas","text":"Considere a seguinte gram\u00e1tica para express\u00f5es aritm\u00e9ticas simples: Express\u00e3o \u2192 Termo {(\"+\" | \"-\") Termo} Termo \u2192 Fator {(\"*\" | \"/\") Fator} Fator \u2192 N\u00famero | \"(\" Express\u00e3o \")\"","title":"Exemplos de Gram\u00e1ticas"},{"location":"aula3/#exemplo-de-implementacao","text":"Abaixo est\u00e1 uma implementa\u00e7\u00e3o b\u00e1sica de um analisador sint\u00e1tico para express\u00f5es aritm\u00e9ticas em Python. Ele utiliza um analisador l\u00e9xico para gerar tokens e, em seguida, constr\u00f3i uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST). import re # Analisador L\u00e9xico def lexical_analysis(expression): token_specification = [ ('NUMBER', r'\\d+'), ('PLUS', r'\\+'), ('MINUS', r'-'), ('TIMES', r'\\*'), ('DIVIDE', r'/'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('SKIP', r'[ \\t]+'), ('MISMATCH', r'.'), ] tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_specification) get_token = re.compile(tok_regex).match line = expression.strip() pos = 0 tokens = [] while pos < len(line): match = get_token(line, pos) if match is None: raise RuntimeError(f'Erro l\u00e9xico em {line[pos]}') pos = match.end() token_type = match.lastgroup if token_type == 'NUMBER': value = int(match.group(token_type)) tokens.append((token_type, value)) elif token_type != 'SKIP': tokens.append((token_type, match.group(token_type))) return tokens # Analisador Sint\u00e1tico class Parser: def __init__(self, tokens): self.tokens = tokens self.pos = 0 def parse(self): return self.expression() def expression(self): node = self.term() while self.current_token() in ('PLUS', 'MINUS'): token = self.current_token() self.next_token() node = (token, node, self.term()) return node def term(self): node = self.factor() while self.current_token() in ('TIMES', 'DIVIDE'): token = self.current_token() self.next_token() node = (token, node, self.factor()) return node def factor(self): token = self.current_token() if token == 'NUMBER': self.next_token() return ('NUMBER', self.current_value()) elif token == 'LPAREN': self.next_token() node = self.expression() if self.current_token() == 'RPAREN': self.next_token() return node else: raise RuntimeError(\"Erro: ')' esperado\") else: raise RuntimeError(f\"Erro: Token inesperado {token}\") def current_token(self): return self.tokens[self.pos][0] if self.pos < len(self.tokens) else None def current_value(self): return self.tokens[self.pos - 1][1] def next_token(self): self.pos += 1 # Fun\u00e7\u00e3o principal para realizar a an\u00e1lise l\u00e9xica e sint\u00e1tica def main(): expression = \"3 + 5 * ( 10 - 20 ) / 2\" tokens = lexical_analysis(expression) print(\"Tokens:\", tokens) parser = Parser(tokens) ast = parser.parse() print(\"AST:\", ast) # Executar a fun\u00e7\u00e3o principal if __name__ == \"__main__\": main()","title":"Exemplo de Implementa\u00e7\u00e3o"},{"location":"aula3/#desafio-em-python_1","text":"Agora que voc\u00ea compreendeu o b\u00e1sico sobre an\u00e1lise sint\u00e1tica, aqui est\u00e1 um desafio para colocar em pr\u00e1tica seus conhecimentos.","title":"Desafio em Python"},{"location":"aula3/#desafio-implementar-um-analisador-sintatico-completo","text":"Escreva um analisador sint\u00e1tico que, al\u00e9m de analisar express\u00f5es aritm\u00e9ticas simples, seja capaz de analisar express\u00f5es com vari\u00e1veis. Considere a seguinte gram\u00e1tica estendida: Express\u00e3o \u2192 Termo {(\"+\" | \"-\") Termo} Termo \u2192 Fator {(\"*\" | \"/\") Fator} Fator \u2192 N\u00famero | Identificador | \"(\" Express\u00e3o \")\" Identificador \u2192 [a-zA-Z_][a-zA-Z0-9_]* Implemente a fun\u00e7\u00e3o parse para lidar com vari\u00e1veis e teste-a com uma express\u00e3o que inclua vari\u00e1veis. import re def lexical_analysis(expression): token_specification = [ ('NUMBER', r'\\d+'), ('ID', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('PLUS', r'\\+'), ('MINUS', r'-'), ('TIMES', r'\\*'), ('DIVIDE', r'/'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('SKIP', r'[ \\t]+'), ('MISMATCH', r'.'), ] tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_specification) get_token = re.compile(tok_regex).match line = expression.strip() pos = 0 tokens = [] while pos < len(line): match = get_token(line, pos) if match is None: raise RuntimeError(f'Erro l\u00e9xico em {line[pos]}') pos = match.end() token_type = match.lastgroup if token_type in ('NUMBER', 'ID'): value = match.group(token_type) tokens.append((token_type, value)) elif token_type != 'SKIP': tokens.append((token_type, match.group(token_type))) return tokens class Parser: def __init__(self, tokens): self.tokens = tokens self.pos = 0 def parse(self): return self.expression() def expression(self): node = self.term() while self.current_token() in ('PLUS', 'MINUS'): token = self.current_token() self.next_token() node = (token, node, self.term()) return node def term(self): node = self.factor() while self.current_token() in ('TIMES', 'DIVIDE'): token = self.current_token() self.next_token() node = (token, node, self.factor()) return node def factor(self): token = self.current_token() if token == 'NUMBER': self.next_token() return ('NUMBER', self.current_value()) elif token == 'ID': self.next_token() return ('ID', self.current_value()) elif token == 'LPAREN': self.next_token() node = self.expression() if self.current_token() == 'RPAREN': self.next_token() return node else: raise RuntimeError(\"Erro: ')' esperado\") else: raise RuntimeError(f\"Erro: Token inesperado {token}\") def current_token(self): return self.tokens[self.pos][0] if self.pos < len(self.tokens) else None def current_value(self): return self.tokens[self.pos - 1][1] def next_token(self): self.pos += 1 def main(): expression = \"x + 3 * ( y - 2 ) / z\" tokens = lexical_analysis(expression) print(\"Tokens:\", tokens) parser = Parser(tokens) ast = parser.parse() print(\"AST:\", ast) if __name__ == \"__main__\": main()","title":"Desafio: Implementar um Analisador Sint\u00e1tico Completo"},{"location":"aula3/#teste-esperado_1","text":"Para a express\u00e3o \"x + 3 * ( y - 2 ) / z\" , a sa\u00edda esperada seria: Tokens: [('ID', 'x'), ('PLUS', '+'), ('NUMBER', '3'), ('TIMES', '*'), ('LPAREN', '('), ('ID', 'y'), ('MINUS', '-'), ('NUMBER', '2'), ('RPAREN', ')'), ('DIVIDE', '/'), ('ID', 'z')] AST: ('PLUS', ('ID', 'x'), ('DIVIDE', ('TIMES', ('NUMBER', '3'), ('MINUS', ('ID', 'y'), ('NUMBER', '2'))), ('ID', 'z'))) Boa sorte e divirta-se resolvendo o desafio!","title":"Teste esperado"},{"location":"aula3/#resumao","text":"","title":"Resum\u00e3o!"},{"location":"aula3/#analise-de-compilacao-lexica-sintatica-e-semantica","text":"","title":"An\u00e1lise de Compila\u00e7\u00e3o: L\u00e9xica, Sint\u00e1tica e Sem\u00e2ntica"},{"location":"aula3/#introducao_2","text":"O processo de compila\u00e7\u00e3o de um programa pode ser dividido em v\u00e1rias fases distintas. Cada fase tem um papel crucial na transforma\u00e7\u00e3o do c\u00f3digo fonte em c\u00f3digo execut\u00e1vel. As tr\u00eas principais fases s\u00e3o a an\u00e1lise l\u00e9xica, a an\u00e1lise sint\u00e1tica e a an\u00e1lise sem\u00e2ntica.","title":"Introdu\u00e7\u00e3o"},{"location":"aula3/#analise-lexica_1","text":"","title":"An\u00e1lise L\u00e9xica"},{"location":"aula3/#objetivo","text":"A an\u00e1lise l\u00e9xica, tamb\u00e9m conhecida como lexing ou tokeniza\u00e7\u00e3o, \u00e9 a primeira etapa do processo de compila\u00e7\u00e3o. Seu objetivo \u00e9 converter a sequ\u00eancia de caracteres do c\u00f3digo fonte em uma sequ\u00eancia de tokens, que s\u00e3o as menores unidades significativas do c\u00f3digo.","title":"Objetivo"},{"location":"aula3/#componentes","text":"Tabela de s\u00edmbolos : Armazena informa\u00e7\u00f5es sobre identificadores e palavras-chave. Regras l\u00e9xicas : Definem padr\u00f5es para reconhecer tokens usando express\u00f5es regulares. Aut\u00f4matos Finitos : Implementam as regras l\u00e9xicas para varrer a entrada e produzir tokens.","title":"Componentes"},{"location":"aula3/#exemplo-de-tokens_1","text":"Para o c\u00f3digo int a = 10; , os tokens podem ser: int , a , = , 10 , ; .","title":"Exemplo de Tokens"},{"location":"aula3/#implementacao","text":"import re def lexical_analysis(expression): token_specification = [ ('NUMBER', r'\\d+'), ('ID', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('PLUS', r'\\+'), ('MINUS', r'-'), ('TIMES', r'\\*'), ('DIVIDE', r'/'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('SKIP', r'[ \\t]+'), ('MISMATCH', r'.'), ] tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_specification) get_token = re.compile(tok_regex).match line = expression.strip() pos = 0 tokens = [] while pos < len(line): match = get_token(line, pos) if match is None: raise RuntimeError(f'Erro l\u00e9xico em {line[pos]}') pos = match.end() token_type = match.lastgroup if token_type in ('NUMBER', 'ID'): value = match.group(token_type) tokens.append((token_type, value)) elif token_type != 'SKIP': tokens.append((token_type, match.group(token_type))) return tokens","title":"Implementa\u00e7\u00e3o"},{"location":"aula3/#analise-sintatica_1","text":"","title":"An\u00e1lise Sint\u00e1tica"},{"location":"aula3/#objetivo_1","text":"A an\u00e1lise sint\u00e1tica, ou parsing, \u00e9 a segunda etapa do processo de compila\u00e7\u00e3o. Seu objetivo \u00e9 analisar a sequ\u00eancia de tokens para construir uma estrutura hier\u00e1rquica, como uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST), que representa a estrutura gramatical do c\u00f3digo.","title":"Objetivo"},{"location":"aula3/#componentes_1","text":"Gram\u00e1tica da linguagem : Conjunto de regras que define a estrutura da linguagem. Analisador l\u00e9xico : Componente que fornece a sequ\u00eancia de tokens. Algoritmo de parsing : Constr\u00f3i a \u00e1rvore de an\u00e1lise a partir dos tokens.","title":"Componentes"},{"location":"aula3/#exemplo-de-gramatica","text":"Para express\u00f5es aritm\u00e9ticas simples: - Express\u00e3o \u2192 Termo {(\"+\" | \"-\") Termo} - Termo \u2192 Fator {(\"*\" | \"/\") Fator} - Fator \u2192 N\u00famero | Identificador | \"(\" Express\u00e3o \")\"","title":"Exemplo de Gram\u00e1tica"},{"location":"aula3/#implementacao_1","text":"class Parser: def __init__(self, tokens): self.tokens = tokens self.pos = 0 def parse(self): return self.expression() def expression(self): node = self.term() while self.current_token() in ('PLUS', 'MINUS'): token = self.current_token() self.next_token() node = (token, node, self.term()) return node def term(self): node = self.factor() while self.current_token() in ('TIMES', 'DIVIDE'): token = self.current_token() self.next_token() node = (token, node, self.factor()) return node def factor(self): token = self.current_token() if token == 'NUMBER': self.next_token() return ('NUMBER', self.current_value()) elif token == 'ID': self.next_token() return ('ID', self.current_value()) elif token == 'LPAREN': self.next_token() node = self.expression() if self.current_token() == 'RPAREN': self.next_token() return node else: raise RuntimeError(\"Erro: ')' esperado\") else: raise RuntimeError(f\"Erro: Token inesperado {token}\") def current_token(self): return self.tokens[self.pos][0] if self.pos < len(self.tokens) else None def current_value(self): return self.tokens[self.pos - 1][1] def next_token(self): self.pos += 1 # Fun\u00e7\u00e3o principal para realizar a an\u00e1lise l\u00e9xica e sint\u00e1tica def main(): expression = \"x + 3 * ( y - 2 ) / z\" tokens = lexical_analysis(expression) print(\"Tokens:\", tokens) parser = Parser(tokens) ast = parser.parse() print(\"AST:\", ast) if __name__ == \"__main__\": main()","title":"Implementa\u00e7\u00e3o"},{"location":"aula3/#analise-semantica","text":"","title":"An\u00e1lise Sem\u00e2ntica"},{"location":"aula3/#objetivo_2","text":"A an\u00e1lise sem\u00e2ntica \u00e9 a terceira etapa do processo de compila\u00e7\u00e3o. Seu objetivo \u00e9 verificar a corre\u00e7\u00e3o sem\u00e2ntica do programa, assegurando que ele faz sentido dentro do contexto da linguagem. Isso inclui verifica\u00e7\u00e3o de tipos, escopo de vari\u00e1veis e outras regras sem\u00e2nticas.","title":"Objetivo"},{"location":"aula3/#componentes_2","text":"Tabela de s\u00edmbolos : Armazena informa\u00e7\u00f5es sobre identificadores, seus tipos e escopos. Regras sem\u00e2nticas : Definem as verifica\u00e7\u00f5es necess\u00e1rias para garantir a corre\u00e7\u00e3o sem\u00e2ntica do c\u00f3digo.","title":"Componentes"},{"location":"aula3/#processo","text":"Verifica\u00e7\u00e3o de tipos : Assegurar que as opera\u00e7\u00f5es s\u00e3o realizadas entre tipos compat\u00edveis. Resolu\u00e7\u00e3o de identificadores : Garantir que todas as vari\u00e1veis e fun\u00e7\u00f5es est\u00e3o declaradas antes de serem usadas. An\u00e1lise de escopo : Verificar que as vari\u00e1veis est\u00e3o acess\u00edveis apenas dentro do seu escopo.","title":"Processo"},{"location":"aula3/#exemplo-de-verificacao-de-tipos","text":"Para a express\u00e3o x + 3 , onde x \u00e9 uma vari\u00e1vel do tipo int : class SemanticAnalyzer: def __init__(self, ast, symbol_table): self.ast = ast self.symbol_table = symbol_table def analyze(self): return self._analyze_node(self.ast) def _analyze_node(self, node): if isinstance(node, tuple): op = node[0] left = self._analyze_node(node[1]) right = self._analyze_node(node[2]) if op in ('PLUS', 'MINUS', 'TIMES', 'DIVIDE'): if left != 'int' or right != 'int': raise RuntimeError(f\"Erro sem\u00e2ntico: opera\u00e7\u00e3o {op} inv\u00e1lida entre {left} e {right}\") return 'int' elif node[0] == 'NUMBER': return 'int' elif node[0] == 'ID': identifier = node[1] if identifier not in self.symbol_table: raise RuntimeError(f\"Erro sem\u00e2ntico: vari\u00e1vel {identifier} n\u00e3o declarada\") return self.symbol_table[identifier] else: raise RuntimeError(f\"Erro sem\u00e2ntico: n\u00f3 inv\u00e1lido {node}\") # Fun\u00e7\u00e3o principal para realizar a an\u00e1lise sem\u00e2ntica def main(): expression = \"x + 3 * ( y - 2 ) / z\" tokens = lexical_analysis(expression) print(\"Tokens:\", tokens) parser = Parser(tokens) ast = parser.parse() print(\"AST:\", ast) symbol_table = {'x': 'int', 'y': 'int', 'z': 'int'} analyzer = SemanticAnalyzer(ast, symbol_table) analyzer.analyze() print(\"An\u00e1lise sem\u00e2ntica conclu\u00edda com sucesso\") if __name__ == \"__main__\": main()","title":"Exemplo de Verifica\u00e7\u00e3o de Tipos"},{"location":"aula3/#conclusao","text":"A an\u00e1lise l\u00e9xica, sint\u00e1tica e sem\u00e2ntica s\u00e3o etapas fundamentais do processo de compila\u00e7\u00e3o, cada uma desempenhando um papel crucial na transforma\u00e7\u00e3o do c\u00f3digo fonte em um programa execut\u00e1vel. A an\u00e1lise l\u00e9xica converte o c\u00f3digo em tokens, a an\u00e1lise sint\u00e1tica constr\u00f3i a estrutura gramatical e a an\u00e1lise sem\u00e2ntica verifica a corre\u00e7\u00e3o contextual do programa. Compreender essas etapas \u00e9 essencial para o desenvolvimento de compiladores e int\u00e9rpretes eficientes.","title":"Conclus\u00e3o"},{"location":"aula4/","text":"Aula: An\u00e1lise Sem\u00e2ntica em Compiladores Objetivos da Aula Entender o que \u00e9 a an\u00e1lise sem\u00e2ntica no contexto de compiladores. Aprender as principais tarefas realizadas durante a an\u00e1lise sem\u00e2ntica. Realizar uma atividade pr\u00e1tica utilizando Python para implementar verifica\u00e7\u00f5es sem\u00e2nticas. Introdu\u00e7\u00e3o \u00e0 An\u00e1lise Sem\u00e2ntica O que \u00e9 An\u00e1lise Sem\u00e2ntica? A an\u00e1lise sem\u00e2ntica \u00e9 uma fase crucial do processo de compila\u00e7\u00e3o que ocorre ap\u00f3s a an\u00e1lise l\u00e9xica e sint\u00e1tica. Enquanto a an\u00e1lise l\u00e9xica trata da identifica\u00e7\u00e3o de tokens e a an\u00e1lise sint\u00e1tica verifica a estrutura gramatical do c\u00f3digo-fonte, a an\u00e1lise sem\u00e2ntica assegura que o c\u00f3digo esteja conforme as regras sem\u00e2nticas da linguagem de programa\u00e7\u00e3o. Esta fase verifica a correta utiliza\u00e7\u00e3o de tipos de vari\u00e1veis, a resolu\u00e7\u00e3o de refer\u00eancias a vari\u00e1veis e fun\u00e7\u00f5es, e outros aspectos sem\u00e2nticos do c\u00f3digo. Principais Tarefas da An\u00e1lise Sem\u00e2ntica Verifica\u00e7\u00e3o de Tipos: Assegura que opera\u00e7\u00f5es e atribui\u00e7\u00f5es entre vari\u00e1veis s\u00e3o feitas com tipos compat\u00edveis. Resolu\u00e7\u00e3o de Identificadores: Garante que todas as vari\u00e1veis e fun\u00e7\u00f5es referenciadas est\u00e3o devidamente declaradas. Verifica\u00e7\u00e3o de Escopo: Confirma que vari\u00e1veis e fun\u00e7\u00f5es s\u00e3o acessadas dentro de seus escopos v\u00e1lidos. Detec\u00e7\u00e3o de Erros Sem\u00e2nticos: Identifica problemas como o uso de vari\u00e1veis n\u00e3o inicializadas, fun\u00e7\u00f5es chamadas com par\u00e2metros incorretos, etc. Exemplo Pr\u00e1tico com Python Atividade: Implementa\u00e7\u00e3o de Verifica\u00e7\u00f5es Sem\u00e2nticas Vamos implementar um simples analisador sem\u00e2ntico em Python que verifica declara\u00e7\u00f5es de vari\u00e1veis e compatibilidade de tipos em um mini-linguagem de programa\u00e7\u00e3o fict\u00edcia. Passo 1: Definir a Gram\u00e1tica e a Tabela de S\u00edmbolos C\u00f3digo de Exemplo # Definindo a Tabela de S\u00edmbolos symbol_table = {} # Fun\u00e7\u00e3o para adicionar uma vari\u00e1vel \u00e0 tabela de s\u00edmbolos def declare_variable(name, var_type): if name in symbol_table: raise Exception(f\"Erro: Vari\u00e1vel '{name}' j\u00e1 declarada.\") symbol_table[name] = var_type # Fun\u00e7\u00e3o para verificar o tipo de uma vari\u00e1vel def check_variable(name): if name not in symbol_table: raise Exception(f\"Erro: Vari\u00e1vel '{name}' n\u00e3o declarada.\") return symbol_table[name] # Fun\u00e7\u00e3o para verificar a atribui\u00e7\u00e3o de tipos def assign_variable(name, value, value_type): var_type = check_variable(name) if var_type != value_type: raise Exception(f\"Erro: Tipo incompat\u00edvel. '{name}' \u00e9 do tipo '{var_type}' mas foi atribu\u00eddo um valor do tipo '{value_type}'.\") # Fun\u00e7\u00e3o para imprimir a tabela de s\u00edmbolos (para depura\u00e7\u00e3o) def print_symbol_table(): print(\"Tabela de S\u00edmbolos:\") for name, var_type in symbol_table.items(): print(f\"{name}: {var_type}\") # Exemplo de uso das fun\u00e7\u00f5es try: declare_variable(\"x\", \"int\") declare_variable(\"y\", \"float\") assign_variable(\"x\", 10, \"int\") assign_variable(\"y\", 3.14, \"float\") print_symbol_table() except Exception as e: print(e) Explica\u00e7\u00e3o do C\u00f3digo Tabela de S\u00edmbolos: Um dicion\u00e1rio que armazena os nomes das vari\u00e1veis e seus respectivos tipos. Fun\u00e7\u00f5es de Declara\u00e7\u00e3o e Verifica\u00e7\u00e3o: declare_variable adiciona uma vari\u00e1vel \u00e0 tabela de s\u00edmbolos, check_variable verifica se uma vari\u00e1vel foi declarada, e assign_variable verifica a compatibilidade de tipos na atribui\u00e7\u00e3o de valores. Teste das Fun\u00e7\u00f5es: Declaramos duas vari\u00e1veis ( x e y ), atribuimos valores compat\u00edveis a elas, e imprimimos a tabela de s\u00edmbolos. Passo 2: Verifica\u00e7\u00f5es Adicionais Podemos estender este exemplo para incluir verifica\u00e7\u00f5es mais complexas, como: - Verifica\u00e7\u00e3o de Fun\u00e7\u00f5es: Assegurar que as fun\u00e7\u00f5es sejam chamadas com os par\u00e2metros corretos. - Escopo de Vari\u00e1veis: Implementar uma pilha de escopos para lidar com vari\u00e1veis locais e globais. Exerc\u00edcio para os Alunos Adicionar Suporte para Fun\u00e7\u00f5es: Implementar a declara\u00e7\u00e3o e verifica\u00e7\u00e3o de fun\u00e7\u00f5es, assegurando que as chamadas de fun\u00e7\u00e3o utilizem o n\u00famero correto de par\u00e2metros com os tipos esperados. Implementar Escopos: Modificar a tabela de s\u00edmbolos para suportar escopos aninhados e garantir que vari\u00e1veis locais n\u00e3o interfiram com vari\u00e1veis globais. Conclus\u00e3o A an\u00e1lise sem\u00e2ntica \u00e9 uma etapa essencial para garantir que o c\u00f3digo-fonte seja v\u00e1lido em termos de regras sem\u00e2nticas da linguagem de programa\u00e7\u00e3o. Compreender e implementar estas verifica\u00e7\u00f5es ajuda a detectar erros antes da gera\u00e7\u00e3o do c\u00f3digo de m\u00e1quina, melhorando a confiabilidade e a corre\u00e7\u00e3o dos programas compilados. Refer\u00eancias Livro: \"Compiladores: Princ\u00edpios, T\u00e9cnicas e Ferramentas\" de Aho, Lam, Sethi, e Ullman. Documenta\u00e7\u00e3o Python: https://docs.python.org/3/ Resum\u00e3o do M\u00f3dulo Pontos Principais An\u00e1lise L\u00e9xica Descri\u00e7\u00e3o: Primeira fase do processo de compila\u00e7\u00e3o, respons\u00e1vel por dividir o c\u00f3digo-fonte em unidades significativas chamadas tokens. Esses tokens incluem palavras-chave, identificadores, n\u00fameros, e s\u00edmbolos. Import\u00e2ncia: Facilita a an\u00e1lise subsequente do c\u00f3digo, preparando-o para as fases de an\u00e1lise sint\u00e1tica e sem\u00e2ntica. An\u00e1lise Sint\u00e1tica Descri\u00e7\u00e3o: Verifica se a estrutura gramatical do c\u00f3digo-fonte segue as regras da linguagem de programa\u00e7\u00e3o. Constr\u00f3i uma \u00e1rvore de deriva\u00e7\u00e3o que representa a estrutura do c\u00f3digo. Import\u00e2ncia: Garante que o c\u00f3digo esteja sintaticamente correto antes de passar para a an\u00e1lise sem\u00e2ntica. An\u00e1lise Sem\u00e2ntica Descri\u00e7\u00e3o: Garante que o c\u00f3digo-fonte obede\u00e7a \u00e0s regras sem\u00e2nticas da linguagem, como a correta utiliza\u00e7\u00e3o de tipos de vari\u00e1veis e a resolu\u00e7\u00e3o de refer\u00eancias a vari\u00e1veis e fun\u00e7\u00f5es. Import\u00e2ncia: Detecta e relata erros sem\u00e2nticos, assegurando que o c\u00f3digo tenha significado correto e coer\u00eancia. Otimiza\u00e7\u00e3o de C\u00f3digo Descri\u00e7\u00e3o: Processo que melhora o desempenho do c\u00f3digo gerado pelo compilador, reorganizando instru\u00e7\u00f5es para reduzir opera\u00e7\u00f5es redundantes e aumentar a efici\u00eancia. Import\u00e2ncia: Produz c\u00f3digo mais eficiente, que executa mais rapidamente e utiliza menos recursos. Compilador Descri\u00e7\u00e3o: Ferramenta de software que traduz c\u00f3digo de alto n\u00edvel (como C++ ou Java) em c\u00f3digo de m\u00e1quina ou outra forma de c\u00f3digo intermedi\u00e1rio. Import\u00e2ncia: Permite a execu\u00e7\u00e3o de programas escritos em linguagens de alto n\u00edvel em computadores, traduzindo-os para um formato compreens\u00edvel pelo hardware. Tabela de S\u00edmbolos e Gram\u00e1tica Descri\u00e7\u00e3o: Utilizadas pelo analisador sem\u00e2ntico para processar a \u00e1rvore de deriva\u00e7\u00e3o. A tabela de s\u00edmbolos mant\u00e9m informa\u00e7\u00f5es sobre vari\u00e1veis, fun\u00e7\u00f5es, e outros elementos do c\u00f3digo. Import\u00e2ncia: Facilita a verifica\u00e7\u00e3o sem\u00e2ntica e a corre\u00e7\u00e3o de erros relacionados ao uso de vari\u00e1veis e fun\u00e7\u00f5es no c\u00f3digo. Linguagem Pascal Descri\u00e7\u00e3o: Linguagem de programa\u00e7\u00e3o apresentada em 1970 por Niklaus Emil Wirth, que segue os paradigmas estruturado, imperativo e procedural. Um exemplo t\u00edpico \u00e9 um programa que recebe dois n\u00fameros diferentes e determina o maior. Import\u00e2ncia: Pascal \u00e9 usada para ilustrar conceitos de programa\u00e7\u00e3o estruturada e a import\u00e2ncia da verifica\u00e7\u00e3o de tipos e escopos em compiladores. An\u00e1lise de Tipos de Dados Descri\u00e7\u00e3o: Verifica\u00e7\u00e3o realizada pelo analisador sem\u00e2ntico para assegurar que operandos e operadores s\u00e3o compat\u00edveis, evitando atribui\u00e7\u00f5es inconsistentes. Import\u00e2ncia: Essencial para manter a integridade e coer\u00eancia dos dados no c\u00f3digo, prevenindo erros de execu\u00e7\u00e3o. Fun\u00e7\u00f5es do Analisador Sem\u00e2ntico Descri\u00e7\u00e3o: Detecta vari\u00e1veis declaradas mas n\u00e3o utilizadas, fun\u00e7\u00f5es declaradas em duplicidade e previne o uso de nomes de fun\u00e7\u00f5es por vari\u00e1veis. Import\u00e2ncia: Ajuda a manter o c\u00f3digo organizado e livre de erros que possam afetar sua execu\u00e7\u00e3o e manuten\u00e7\u00e3o.","title":"Aula 4"},{"location":"aula4/#aula-analise-semantica-em-compiladores","text":"","title":"Aula: An\u00e1lise Sem\u00e2ntica em Compiladores"},{"location":"aula4/#objetivos-da-aula","text":"Entender o que \u00e9 a an\u00e1lise sem\u00e2ntica no contexto de compiladores. Aprender as principais tarefas realizadas durante a an\u00e1lise sem\u00e2ntica. Realizar uma atividade pr\u00e1tica utilizando Python para implementar verifica\u00e7\u00f5es sem\u00e2nticas.","title":"Objetivos da Aula"},{"location":"aula4/#introducao-a-analise-semantica","text":"","title":"Introdu\u00e7\u00e3o \u00e0 An\u00e1lise Sem\u00e2ntica"},{"location":"aula4/#o-que-e-analise-semantica","text":"A an\u00e1lise sem\u00e2ntica \u00e9 uma fase crucial do processo de compila\u00e7\u00e3o que ocorre ap\u00f3s a an\u00e1lise l\u00e9xica e sint\u00e1tica. Enquanto a an\u00e1lise l\u00e9xica trata da identifica\u00e7\u00e3o de tokens e a an\u00e1lise sint\u00e1tica verifica a estrutura gramatical do c\u00f3digo-fonte, a an\u00e1lise sem\u00e2ntica assegura que o c\u00f3digo esteja conforme as regras sem\u00e2nticas da linguagem de programa\u00e7\u00e3o. Esta fase verifica a correta utiliza\u00e7\u00e3o de tipos de vari\u00e1veis, a resolu\u00e7\u00e3o de refer\u00eancias a vari\u00e1veis e fun\u00e7\u00f5es, e outros aspectos sem\u00e2nticos do c\u00f3digo.","title":"O que \u00e9 An\u00e1lise Sem\u00e2ntica?"},{"location":"aula4/#principais-tarefas-da-analise-semantica","text":"Verifica\u00e7\u00e3o de Tipos: Assegura que opera\u00e7\u00f5es e atribui\u00e7\u00f5es entre vari\u00e1veis s\u00e3o feitas com tipos compat\u00edveis. Resolu\u00e7\u00e3o de Identificadores: Garante que todas as vari\u00e1veis e fun\u00e7\u00f5es referenciadas est\u00e3o devidamente declaradas. Verifica\u00e7\u00e3o de Escopo: Confirma que vari\u00e1veis e fun\u00e7\u00f5es s\u00e3o acessadas dentro de seus escopos v\u00e1lidos. Detec\u00e7\u00e3o de Erros Sem\u00e2nticos: Identifica problemas como o uso de vari\u00e1veis n\u00e3o inicializadas, fun\u00e7\u00f5es chamadas com par\u00e2metros incorretos, etc.","title":"Principais Tarefas da An\u00e1lise Sem\u00e2ntica"},{"location":"aula4/#exemplo-pratico-com-python","text":"","title":"Exemplo Pr\u00e1tico com Python"},{"location":"aula4/#atividade-implementacao-de-verificacoes-semanticas","text":"Vamos implementar um simples analisador sem\u00e2ntico em Python que verifica declara\u00e7\u00f5es de vari\u00e1veis e compatibilidade de tipos em um mini-linguagem de programa\u00e7\u00e3o fict\u00edcia.","title":"Atividade: Implementa\u00e7\u00e3o de Verifica\u00e7\u00f5es Sem\u00e2nticas"},{"location":"aula4/#passo-1-definir-a-gramatica-e-a-tabela-de-simbolos","text":"","title":"Passo 1: Definir a Gram\u00e1tica e a Tabela de S\u00edmbolos"},{"location":"aula4/#codigo-de-exemplo","text":"# Definindo a Tabela de S\u00edmbolos symbol_table = {} # Fun\u00e7\u00e3o para adicionar uma vari\u00e1vel \u00e0 tabela de s\u00edmbolos def declare_variable(name, var_type): if name in symbol_table: raise Exception(f\"Erro: Vari\u00e1vel '{name}' j\u00e1 declarada.\") symbol_table[name] = var_type # Fun\u00e7\u00e3o para verificar o tipo de uma vari\u00e1vel def check_variable(name): if name not in symbol_table: raise Exception(f\"Erro: Vari\u00e1vel '{name}' n\u00e3o declarada.\") return symbol_table[name] # Fun\u00e7\u00e3o para verificar a atribui\u00e7\u00e3o de tipos def assign_variable(name, value, value_type): var_type = check_variable(name) if var_type != value_type: raise Exception(f\"Erro: Tipo incompat\u00edvel. '{name}' \u00e9 do tipo '{var_type}' mas foi atribu\u00eddo um valor do tipo '{value_type}'.\") # Fun\u00e7\u00e3o para imprimir a tabela de s\u00edmbolos (para depura\u00e7\u00e3o) def print_symbol_table(): print(\"Tabela de S\u00edmbolos:\") for name, var_type in symbol_table.items(): print(f\"{name}: {var_type}\") # Exemplo de uso das fun\u00e7\u00f5es try: declare_variable(\"x\", \"int\") declare_variable(\"y\", \"float\") assign_variable(\"x\", 10, \"int\") assign_variable(\"y\", 3.14, \"float\") print_symbol_table() except Exception as e: print(e)","title":"C\u00f3digo de Exemplo"},{"location":"aula4/#explicacao-do-codigo","text":"Tabela de S\u00edmbolos: Um dicion\u00e1rio que armazena os nomes das vari\u00e1veis e seus respectivos tipos. Fun\u00e7\u00f5es de Declara\u00e7\u00e3o e Verifica\u00e7\u00e3o: declare_variable adiciona uma vari\u00e1vel \u00e0 tabela de s\u00edmbolos, check_variable verifica se uma vari\u00e1vel foi declarada, e assign_variable verifica a compatibilidade de tipos na atribui\u00e7\u00e3o de valores. Teste das Fun\u00e7\u00f5es: Declaramos duas vari\u00e1veis ( x e y ), atribuimos valores compat\u00edveis a elas, e imprimimos a tabela de s\u00edmbolos.","title":"Explica\u00e7\u00e3o do C\u00f3digo"},{"location":"aula4/#passo-2-verificacoes-adicionais","text":"Podemos estender este exemplo para incluir verifica\u00e7\u00f5es mais complexas, como: - Verifica\u00e7\u00e3o de Fun\u00e7\u00f5es: Assegurar que as fun\u00e7\u00f5es sejam chamadas com os par\u00e2metros corretos. - Escopo de Vari\u00e1veis: Implementar uma pilha de escopos para lidar com vari\u00e1veis locais e globais.","title":"Passo 2: Verifica\u00e7\u00f5es Adicionais"},{"location":"aula4/#exercicio-para-os-alunos","text":"Adicionar Suporte para Fun\u00e7\u00f5es: Implementar a declara\u00e7\u00e3o e verifica\u00e7\u00e3o de fun\u00e7\u00f5es, assegurando que as chamadas de fun\u00e7\u00e3o utilizem o n\u00famero correto de par\u00e2metros com os tipos esperados. Implementar Escopos: Modificar a tabela de s\u00edmbolos para suportar escopos aninhados e garantir que vari\u00e1veis locais n\u00e3o interfiram com vari\u00e1veis globais.","title":"Exerc\u00edcio para os Alunos"},{"location":"aula4/#conclusao","text":"A an\u00e1lise sem\u00e2ntica \u00e9 uma etapa essencial para garantir que o c\u00f3digo-fonte seja v\u00e1lido em termos de regras sem\u00e2nticas da linguagem de programa\u00e7\u00e3o. Compreender e implementar estas verifica\u00e7\u00f5es ajuda a detectar erros antes da gera\u00e7\u00e3o do c\u00f3digo de m\u00e1quina, melhorando a confiabilidade e a corre\u00e7\u00e3o dos programas compilados.","title":"Conclus\u00e3o"},{"location":"aula4/#referencias","text":"Livro: \"Compiladores: Princ\u00edpios, T\u00e9cnicas e Ferramentas\" de Aho, Lam, Sethi, e Ullman. Documenta\u00e7\u00e3o Python: https://docs.python.org/3/","title":"Refer\u00eancias"},{"location":"aula4/#resumao-do-modulo","text":"","title":"Resum\u00e3o do M\u00f3dulo"},{"location":"aula4/#pontos-principais","text":"","title":"Pontos Principais"},{"location":"aula4/#analise-lexica","text":"Descri\u00e7\u00e3o: Primeira fase do processo de compila\u00e7\u00e3o, respons\u00e1vel por dividir o c\u00f3digo-fonte em unidades significativas chamadas tokens. Esses tokens incluem palavras-chave, identificadores, n\u00fameros, e s\u00edmbolos. Import\u00e2ncia: Facilita a an\u00e1lise subsequente do c\u00f3digo, preparando-o para as fases de an\u00e1lise sint\u00e1tica e sem\u00e2ntica.","title":"An\u00e1lise L\u00e9xica"},{"location":"aula4/#analise-sintatica","text":"Descri\u00e7\u00e3o: Verifica se a estrutura gramatical do c\u00f3digo-fonte segue as regras da linguagem de programa\u00e7\u00e3o. Constr\u00f3i uma \u00e1rvore de deriva\u00e7\u00e3o que representa a estrutura do c\u00f3digo. Import\u00e2ncia: Garante que o c\u00f3digo esteja sintaticamente correto antes de passar para a an\u00e1lise sem\u00e2ntica.","title":"An\u00e1lise Sint\u00e1tica"},{"location":"aula4/#analise-semantica","text":"Descri\u00e7\u00e3o: Garante que o c\u00f3digo-fonte obede\u00e7a \u00e0s regras sem\u00e2nticas da linguagem, como a correta utiliza\u00e7\u00e3o de tipos de vari\u00e1veis e a resolu\u00e7\u00e3o de refer\u00eancias a vari\u00e1veis e fun\u00e7\u00f5es. Import\u00e2ncia: Detecta e relata erros sem\u00e2nticos, assegurando que o c\u00f3digo tenha significado correto e coer\u00eancia.","title":"An\u00e1lise Sem\u00e2ntica"},{"location":"aula4/#otimizacao-de-codigo","text":"Descri\u00e7\u00e3o: Processo que melhora o desempenho do c\u00f3digo gerado pelo compilador, reorganizando instru\u00e7\u00f5es para reduzir opera\u00e7\u00f5es redundantes e aumentar a efici\u00eancia. Import\u00e2ncia: Produz c\u00f3digo mais eficiente, que executa mais rapidamente e utiliza menos recursos.","title":"Otimiza\u00e7\u00e3o de C\u00f3digo"},{"location":"aula4/#compilador","text":"Descri\u00e7\u00e3o: Ferramenta de software que traduz c\u00f3digo de alto n\u00edvel (como C++ ou Java) em c\u00f3digo de m\u00e1quina ou outra forma de c\u00f3digo intermedi\u00e1rio. Import\u00e2ncia: Permite a execu\u00e7\u00e3o de programas escritos em linguagens de alto n\u00edvel em computadores, traduzindo-os para um formato compreens\u00edvel pelo hardware.","title":"Compilador"},{"location":"aula4/#tabela-de-simbolos-e-gramatica","text":"Descri\u00e7\u00e3o: Utilizadas pelo analisador sem\u00e2ntico para processar a \u00e1rvore de deriva\u00e7\u00e3o. A tabela de s\u00edmbolos mant\u00e9m informa\u00e7\u00f5es sobre vari\u00e1veis, fun\u00e7\u00f5es, e outros elementos do c\u00f3digo. Import\u00e2ncia: Facilita a verifica\u00e7\u00e3o sem\u00e2ntica e a corre\u00e7\u00e3o de erros relacionados ao uso de vari\u00e1veis e fun\u00e7\u00f5es no c\u00f3digo.","title":"Tabela de S\u00edmbolos e Gram\u00e1tica"},{"location":"aula4/#linguagem-pascal","text":"Descri\u00e7\u00e3o: Linguagem de programa\u00e7\u00e3o apresentada em 1970 por Niklaus Emil Wirth, que segue os paradigmas estruturado, imperativo e procedural. Um exemplo t\u00edpico \u00e9 um programa que recebe dois n\u00fameros diferentes e determina o maior. Import\u00e2ncia: Pascal \u00e9 usada para ilustrar conceitos de programa\u00e7\u00e3o estruturada e a import\u00e2ncia da verifica\u00e7\u00e3o de tipos e escopos em compiladores.","title":"Linguagem Pascal"},{"location":"aula4/#analise-de-tipos-de-dados","text":"Descri\u00e7\u00e3o: Verifica\u00e7\u00e3o realizada pelo analisador sem\u00e2ntico para assegurar que operandos e operadores s\u00e3o compat\u00edveis, evitando atribui\u00e7\u00f5es inconsistentes. Import\u00e2ncia: Essencial para manter a integridade e coer\u00eancia dos dados no c\u00f3digo, prevenindo erros de execu\u00e7\u00e3o.","title":"An\u00e1lise de Tipos de Dados"},{"location":"aula4/#funcoes-do-analisador-semantico","text":"Descri\u00e7\u00e3o: Detecta vari\u00e1veis declaradas mas n\u00e3o utilizadas, fun\u00e7\u00f5es declaradas em duplicidade e previne o uso de nomes de fun\u00e7\u00f5es por vari\u00e1veis. Import\u00e2ncia: Ajuda a manter o c\u00f3digo organizado e livre de erros que possam afetar sua execu\u00e7\u00e3o e manuten\u00e7\u00e3o.","title":"Fun\u00e7\u00f5es do Analisador Sem\u00e2ntico"}]}