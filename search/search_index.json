{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem-vindos ao M\u00f3dulo de Compiladores! Introdu\u00e7\u00e3o Ol\u00e1, alunos! Sejam muito bem-vindos ao m\u00f3dulo de Compiladores. Este curso foi cuidadosamente elaborado para gui\u00e1-los atrav\u00e9s dos conceitos fundamentais e avan\u00e7ados da constru\u00e7\u00e3o de compiladores. Ao longo deste m\u00f3dulo, voc\u00eas aprender\u00e3o sobre as diferentes fases de um compilador, desde a an\u00e1lise l\u00e9xica at\u00e9 a gera\u00e7\u00e3o de c\u00f3digo. Objetivos do Curso Neste m\u00f3dulo, voc\u00eas ir\u00e3o: Compreender a estrutura e funcionamento de um compilador. Explorar as t\u00e9cnicas de an\u00e1lise l\u00e9xica, sint\u00e1tica e sem\u00e2ntica. Implementar componentes de um compilador utilizando a linguagem Python. Analisar e otimizar c\u00f3digo gerado. Desenvolver habilidades pr\u00e1ticas atrav\u00e9s de projetos e exerc\u00edcios. Recursos Adicionais Para auxili\u00e1-los no aprendizado, disponibilizamos os seguintes recursos: Material Did\u00e1tico: Apostilas, slides e artigos complementares. Exemplos de C\u00f3digo: Exemplos pr\u00e1ticos em Python para cada fase do compilador. F\u00f3rum de Discuss\u00e3o: Espa\u00e7o para tirar d\u00favidas e discutir t\u00f3picos com colegas e instrutores. Projetos: Projetos pr\u00e1ticos para aplicar os conceitos aprendidos. Contato Se tiverem qualquer d\u00favida ou precisarem de ajuda, n\u00e3o hesitem em entrar em contato com os instrutores: Professor Jo\u00e3o Silva: joao.silva@universidade.com Assistente Maria Oliveira: maria.oliveira@universidade.com Estamos aqui para ajudar e garantir que voc\u00eas tenham uma experi\u00eancia de aprendizado enriquecedora e produtiva. Conclus\u00e3o Estamos muito empolgados em iniciar esta jornada com voc\u00eas. Compiladores s\u00e3o uma parte fundamental da ci\u00eancia da computa\u00e7\u00e3o e esperamos que este curso inspire e capacite voc\u00eas a explorar ainda mais este fascinante campo. Vamos come\u00e7ar! Equipe do M\u00f3dulo de Compiladores Quem ajusta o c\u00f3digo??? Link do formul\u00e1rio: [Form]{https://docs.google.com/forms/d/e/1FAIpQLSe34givDaIYw8ievzqbbqYDMIOQNJbTXMXcvKshXXXj67N7Ug/viewform?usp=sf_link}","title":"Home"},{"location":"#bem-vindos-ao-modulo-de-compiladores","text":"","title":"Bem-vindos ao M\u00f3dulo de Compiladores!"},{"location":"#introducao","text":"Ol\u00e1, alunos! Sejam muito bem-vindos ao m\u00f3dulo de Compiladores. Este curso foi cuidadosamente elaborado para gui\u00e1-los atrav\u00e9s dos conceitos fundamentais e avan\u00e7ados da constru\u00e7\u00e3o de compiladores. Ao longo deste m\u00f3dulo, voc\u00eas aprender\u00e3o sobre as diferentes fases de um compilador, desde a an\u00e1lise l\u00e9xica at\u00e9 a gera\u00e7\u00e3o de c\u00f3digo.","title":"Introdu\u00e7\u00e3o"},{"location":"#objetivos-do-curso","text":"Neste m\u00f3dulo, voc\u00eas ir\u00e3o: Compreender a estrutura e funcionamento de um compilador. Explorar as t\u00e9cnicas de an\u00e1lise l\u00e9xica, sint\u00e1tica e sem\u00e2ntica. Implementar componentes de um compilador utilizando a linguagem Python. Analisar e otimizar c\u00f3digo gerado. Desenvolver habilidades pr\u00e1ticas atrav\u00e9s de projetos e exerc\u00edcios.","title":"Objetivos do Curso"},{"location":"#recursos-adicionais","text":"Para auxili\u00e1-los no aprendizado, disponibilizamos os seguintes recursos: Material Did\u00e1tico: Apostilas, slides e artigos complementares. Exemplos de C\u00f3digo: Exemplos pr\u00e1ticos em Python para cada fase do compilador. F\u00f3rum de Discuss\u00e3o: Espa\u00e7o para tirar d\u00favidas e discutir t\u00f3picos com colegas e instrutores. Projetos: Projetos pr\u00e1ticos para aplicar os conceitos aprendidos.","title":"Recursos Adicionais"},{"location":"#contato","text":"Se tiverem qualquer d\u00favida ou precisarem de ajuda, n\u00e3o hesitem em entrar em contato com os instrutores: Professor Jo\u00e3o Silva: joao.silva@universidade.com Assistente Maria Oliveira: maria.oliveira@universidade.com Estamos aqui para ajudar e garantir que voc\u00eas tenham uma experi\u00eancia de aprendizado enriquecedora e produtiva.","title":"Contato"},{"location":"#conclusao","text":"Estamos muito empolgados em iniciar esta jornada com voc\u00eas. Compiladores s\u00e3o uma parte fundamental da ci\u00eancia da computa\u00e7\u00e3o e esperamos que este curso inspire e capacite voc\u00eas a explorar ainda mais este fascinante campo. Vamos come\u00e7ar! Equipe do M\u00f3dulo de Compiladores","title":"Conclus\u00e3o"},{"location":"#quem-ajusta-o-codigo","text":"Link do formul\u00e1rio: [Form]{https://docs.google.com/forms/d/e/1FAIpQLSe34givDaIYw8ievzqbbqYDMIOQNJbTXMXcvKshXXXj67N7Ug/viewform?usp=sf_link}","title":"Quem ajusta o c\u00f3digo???"},{"location":"aula1/","text":"Aula 1 - Prazer, Compiladores! \ud83e\udd1d\ud83d\udc7e (Continua\u00e7\u00e3o) A Import\u00e2ncia dos Compiladores Na primeira parte da aula, vimos que os compiladores s\u00e3o como tradutores que transformam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o (que humanos entendem) para uma linguagem que o computador entende (linguagem de m\u00e1quina). Imagine que voc\u00ea quer ensinar um amigo a fazer um bolo, mas ele s\u00f3 fala japon\u00eas. Voc\u00ea precisaria de um tradutor para transmitir as instru\u00e7\u00f5es corretamente, certo? \u00c9 exatamente isso que um compilador faz! Ele garante que o computador compreenda e execute as instru\u00e7\u00f5es do seu programa. Governo Dos States Pede para Parar de Utilizar C e Assembly Fases da Compila\u00e7\u00e3o: Uma An\u00e1lise Detalhada Para um problema: A compila\u00e7\u00e3o, como vimos, \u00e9 um processo dividido em etapas. Vamos entender melhor as tr\u00eas principais: An\u00e1lise L\u00e9xica (Fase do \"dicion\u00e1rio\"): Nesta fase, o compilador age como um leitor que examina o c\u00f3digo letra por letra, agrupando-as em \"palavras\" com significado para a linguagem, como nomes de vari\u00e1veis, palavras-chave (ex.: if , else , for ) e operadores (+, -, *, /). Imagine um corretor ortogr\u00e1fico verificando cada palavra e sinal de pontua\u00e7\u00e3o do seu texto. An\u00e1lise L\u00e9xica e Express\u00f5es Regulares A An\u00e1lise L\u00e9xica \u00e9 a primeira fase de um compilador, respons\u00e1vel por dividir o c\u00f3digo-fonte em uma sequ\u00eancia de tokens. Esses tokens representam as unidades b\u00e1sicas da linguagem, como palavras-chave, identificadores, n\u00fameros, operadores, entre outros. Para realizar a An\u00e1lise L\u00e9xica, uma t\u00e9cnica comumente utilizada s\u00e3o as express\u00f5es regulares (regex). As express\u00f5es regulares s\u00e3o padr\u00f5es que descrevem um conjunto de cadeias de caracteres. Elas permitem identificar e extrair partes espec\u00edficas de um texto com base em regras definidas. As express\u00f5es regulares s\u00e3o compostas por caracteres literais e metacaracteres. Alguns metacaracteres comuns incluem: . (ponto): Corresponde a qualquer caractere, exceto uma nova linha. * (asterisco): Corresponde a zero ou mais ocorr\u00eancias do caractere ou grupo anterior. + (mais): Corresponde a uma ou mais ocorr\u00eancias do caractere ou grupo anterior. ? (interroga\u00e7\u00e3o): Corresponde a zero ou uma ocorr\u00eancia do caractere ou grupo anterior. ^ (circunflexo): Corresponde ao in\u00edcio da linha. $ (cifr\u00e3o): Corresponde ao final da linha. [] (colchetes): Define um conjunto de caracteres. Por exemplo, [aeiou] corresponde a qualquer vogal. Al\u00e9m disso, existem classes de caracteres predefinidas, como: \\d : Corresponde a qualquer d\u00edgito (0-9). \\w : Corresponde a qualquer caractere alfanum\u00e9rico (letra ou d\u00edgito). \\s : Corresponde a qualquer caractere de espa\u00e7o em branco (espa\u00e7o, tabula\u00e7\u00e3o, nova linha). Exemplo de express\u00e3o regular para identificar n\u00fameros inteiros: import re # Express\u00e3o regular para n\u00fameros inteiros pattern = r'\\d+' # Texto de exemplo text = \"Eu tenho 25 anos e meu irm\u00e3o tem 30 anos.\" # Encontrar todos os n\u00fameros inteiros no texto matches = re.findall(pattern, text) # Imprimir os n\u00fameros encontrados for match in matches: print(match) Nesse exemplo, a express\u00e3o regular \\d+ \u00e9 usada para encontrar n\u00fameros inteiros no texto. O m\u00e9todo re.findall() \u00e9 utilizado para encontrar todas as ocorr\u00eancias da express\u00e3o regular no texto. O resultado ser\u00e1: 25 30 As express\u00f5es regulares s\u00e3o uma ferramenta poderosa para a An\u00e1lise L\u00e9xica, permitindo identificar e extrair tokens espec\u00edficos do c\u00f3digo-fonte. Elas podem ser combinadas com outras t\u00e9cnicas, como aut\u00f4matos finitos, para construir um analisador l\u00e9xico completo. No entanto, \u00e9 importante ressaltar que as express\u00f5es regulares t\u00eam suas limita\u00e7\u00f5es. Elas s\u00e3o adequadas para identificar padr\u00f5es simples e regulares, mas podem se tornar complexas e dif\u00edceis de manter para linguagens com estruturas mais complexas. Nesses casos, outras t\u00e9cnicas, como a an\u00e1lise sint\u00e1tica, s\u00e3o necess\u00e1rias para lidar com a estrutura hier\u00e1rquica do c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica (Fase da \"gram\u00e1tica\"): Com as \"palavras\" identificadas, o compilador verifica se elas est\u00e3o organizadas de forma correta, seguindo as regras gramaticais da linguagem. \u00c9 como analisar se a ordem das palavras em uma frase faz sentido. Por exemplo, em portugu\u00eas, dizemos \"O gato comeu o peixe\", e n\u00e3o \"Comeu peixe o gato o\". An\u00e1lise Sint\u00e1tica A An\u00e1lise Sint\u00e1tica \u00e9 a segunda fase de um compilador, que ocorre ap\u00f3s a An\u00e1lise L\u00e9xica. Seu objetivo \u00e9 verificar se a sequ\u00eancia de tokens gerada pela An\u00e1lise L\u00e9xica est\u00e1 de acordo com as regras gramaticais da linguagem de programa\u00e7\u00e3o. Em outras palavras, a An\u00e1lise Sint\u00e1tica verifica se o c\u00f3digo-fonte possui uma estrutura v\u00e1lida. Durante a An\u00e1lise Sint\u00e1tica, o compilador constr\u00f3i uma representa\u00e7\u00e3o estruturada do c\u00f3digo-fonte, geralmente na forma de uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). A AST representa a estrutura hier\u00e1rquica do c\u00f3digo, mostrando a rela\u00e7\u00e3o entre os diferentes elementos da linguagem, como express\u00f5es, comandos e blocos de c\u00f3digo. Existem duas abordagens principais para a An\u00e1lise Sint\u00e1tica: An\u00e1lise Sint\u00e1tica Descendente (Top-Down Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir da regra gramatical mais geral e tenta derivar a sequ\u00eancia de tokens de entrada. O m\u00e9todo mais comum \u00e9 a an\u00e1lise preditiva recursiva, que utiliza recurs\u00e3o para percorrer a gram\u00e1tica e construir a AST. A an\u00e1lise descendente \u00e9 adequada para gram\u00e1ticas LL (Left-to-right, Leftmost derivation), onde \u00e9 poss\u00edvel escolher a regra correta a ser aplicada com base nos pr\u00f3ximos tokens de entrada. An\u00e1lise Sint\u00e1tica Ascendente (Bottom-Up Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir dos tokens de entrada e tenta reduzi-los \u00e0s regras gramaticais at\u00e9 chegar \u00e0 regra inicial. O m\u00e9todo mais comum \u00e9 o LR (Left-to-right, Rightmost derivation), que utiliza uma tabela de an\u00e1lise para determinar as a\u00e7\u00f5es a serem tomadas com base nos tokens de entrada. A an\u00e1lise ascendente \u00e9 adequada para gram\u00e1ticas mais complexas e amb\u00edguas, onde a escolha da regra correta depende dos tokens futuros. Exemplo de An\u00e1lise Sint\u00e1tica usando a abordagem descendente: def parse_expression(tokens): def parse_term(tokens): if tokens[0] == 'NUMBER': return ('NUMBER', tokens.pop(0)[1]) elif tokens[0] == 'LPAREN': tokens.pop(0) expr = parse_expression(tokens) if tokens.pop(0) != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") return expr def parse_factor(tokens): term = parse_term(tokens) while tokens and tokens[0] in ['MULTIPLY', 'DIVIDE']: op = tokens.pop(0) right = parse_term(tokens) term = (op, term, right) return term expr = parse_factor(tokens) while tokens and tokens[0] in ['PLUS', 'MINUS']: op = tokens.pop(0) right = parse_factor(tokens) expr = (op, expr, right) return expr Nesse exemplo, a fun\u00e7\u00e3o parse_expression realiza a an\u00e1lise sint\u00e1tica de uma express\u00e3o aritm\u00e9tica simples. Ela utiliza fun\u00e7\u00f5es auxiliares parse_term e parse_factor para lidar com os diferentes n\u00edveis de preced\u00eancia dos operadores. A an\u00e1lise \u00e9 feita de forma recursiva, consumindo os tokens de entrada e construindo a AST correspondente. A An\u00e1lise Sint\u00e1tica \u00e9 uma fase crucial do compilador, pois garante que o c\u00f3digo-fonte esteja estruturalmente correto antes de prosseguir para as pr\u00f3ximas etapas, como a An\u00e1lise Sem\u00e2ntica e a Gera\u00e7\u00e3o de C\u00f3digo. Ela tamb\u00e9m fornece informa\u00e7\u00f5es importantes sobre a estrutura do programa, que s\u00e3o usadas nas fases posteriores do processo de compila\u00e7\u00e3o. An\u00e1lise Sem\u00e2ntica (Fase da \"interpreta\u00e7\u00e3o\"): Ap\u00f3s a an\u00e1lise sint\u00e1tica, o compilador precisa entender o significado do c\u00f3digo. Ele verifica se as opera\u00e7\u00f5es fazem sentido, se as vari\u00e1veis foram declaradas corretamente e se os tipos de dados s\u00e3o compat\u00edveis. \u00c9 como analisar se as frases em um texto fazem sentido juntas e transmitem a mensagem desejada. Funcionamento de um Compilador Vamos rodar tudo isso em Python! Aqui est\u00e1 um exemplo de programa em Python que demonstra as tr\u00eas fases principais de um compilador: an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica e an\u00e1lise sem\u00e2ntica. import re # Defini\u00e7\u00e3o dos tokens tokens = [ (r'\\d+', 'NUMBER'), (r'\\+', 'PLUS'), (r'\\-', 'MINUS'), (r'\\*', 'MULTIPLY'), (r'\\/', 'DIVIDE'), (r'\\(', 'LPAREN'), (r'\\)', 'RPAREN'), (r'\\s+', 'WHITESPACE') ] # An\u00e1lise L\u00e9xica def lexical_analysis(code): lexemes = [] while code: matched = False for token_expr, token_type in tokens: match = re.match(token_expr, code) if match: value = match.group() if token_type != 'WHITESPACE': lexemes.append((token_type, value)) code = code[len(value):] matched = True break if not matched: raise ValueError(f\"Lexema inv\u00e1lido: {code}\") return lexemes # An\u00e1lise Sint\u00e1tica def syntax_analysis(lexemes): ast = [] while lexemes: token_type, value = lexemes.pop(0) if token_type == 'NUMBER': ast.append(('NUMBER', int(value))) elif token_type in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: ast.append((token_type,)) elif token_type == 'LPAREN': sub_expr = syntax_analysis(lexemes) ast.append(('EXPR', sub_expr)) if lexemes.pop(0)[0] != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") else: raise ValueError(f\"Token inesperado: {token_type}\") return ast # An\u00e1lise Sem\u00e2ntica def semantic_analysis(ast): if isinstance(ast, tuple): if ast[0] == 'NUMBER': return ast[1] elif ast[0] in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: return ast[0] elif ast[0] == 'EXPR': return semantic_analysis(ast[1]) elif isinstance(ast, list): if len(ast) != 3: raise ValueError(\"Express\u00e3o inv\u00e1lida\") left = semantic_analysis(ast[0]) op = semantic_analysis(ast[1]) right = semantic_analysis(ast[2]) if not isinstance(left, int) or not isinstance(right, int): raise ValueError(\"Operandos inv\u00e1lidos\") if op == 'PLUS': return left + right elif op == 'MINUS': return left - right elif op == 'MULTIPLY': return left * right elif op == 'DIVIDE': if right == 0: raise ValueError(\"Divis\u00e3o por zero\") return left // right # Exemplo de uso code = \"2 + (3 * 4) - 5\" print(\"C\u00f3digo fonte:\", code) lexemes = lexical_analysis(code) print(\"An\u00e1lise L\u00e9xica:\", lexemes) ast = syntax_analysis(lexemes) print(\"An\u00e1lise Sint\u00e1tica:\", ast) result = semantic_analysis(ast) print(\"An\u00e1lise Sem\u00e2ntica:\", result) Explica\u00e7\u00e3o do programa: An\u00e1lise L\u00e9xica: Definimos os tokens que o compilador reconhecer\u00e1, como n\u00fameros, operadores e par\u00eanteses. A fun\u00e7\u00e3o lexical_analysis recebe o c\u00f3digo-fonte como entrada e retorna uma lista de lexemas (tokens) encontrados no c\u00f3digo. Utilizamos express\u00f5es regulares para identificar os tokens no c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica: A fun\u00e7\u00e3o syntax_analysis recebe a lista de lexemas como entrada e constr\u00f3i uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). Percorremos os lexemas e constru\u00edmos a AST com base na estrutura da express\u00e3o. Tratamos par\u00eanteses aninhados recursivamente. An\u00e1lise Sem\u00e2ntica: A fun\u00e7\u00e3o semantic_analysis recebe a AST como entrada e realiza a an\u00e1lise sem\u00e2ntica. Percorremos a AST recursivamente e avaliamos a express\u00e3o de acordo com as regras sem\u00e2nticas. Verificamos se os operandos s\u00e3o v\u00e1lidos e realizamos as opera\u00e7\u00f5es aritm\u00e9ticas correspondentes. No exemplo de uso, fornecemos um c\u00f3digo-fonte simples \"2 + (3 * 4) - 5\" e aplicamos as tr\u00eas fases do compilador: 1. An\u00e1lise L\u00e9xica: Obtemos a lista de lexemas. 2. An\u00e1lise Sint\u00e1tica: Constru\u00edmos a AST a partir dos lexemas. 3. An\u00e1lise Sem\u00e2ntica: Avaliamos a express\u00e3o e obtemos o resultado final. Esse programa \u00e9 uma simplifica\u00e7\u00e3o das fases de um compilador e serve para ilustrar os conceitos b\u00e1sicos envolvidos em cada fase. Em um compilador real, essas fases s\u00e3o mais complexas e envolvem mais etapas e detalhes. A Tabela de S\u00edmbolos: Organizando a Informa\u00e7\u00e3o A tabela de s\u00edmbolos \u00e9 como um dicion\u00e1rio que o compilador utiliza para armazenar e organizar informa\u00e7\u00f5es sobre todos os elementos do seu c\u00f3digo, como vari\u00e1veis, fun\u00e7\u00f5es e classes. Imagine que voc\u00ea est\u00e1 organizando uma festa e precisa controlar uma lista de convidados. Para cada convidado, voc\u00ea anota seu nome, n\u00famero de telefone e se ele confirmou presen\u00e7a. A tabela de s\u00edmbolos funciona de maneira similar, guardando informa\u00e7\u00f5es importantes sobre cada elemento do seu c\u00f3digo. Atividade em Sala de Aula Objetivo: Compreender a import\u00e2ncia do Debbuging! Enunciado: Sabe o c\u00f3digo mais acima sobre compila\u00e7\u00e3o em python? Pois \u00e9, ele est\u00e1 quebrado, a sua miss\u00e3o \u00e9 ajustar o c\u00f3digo! Observa\u00e7\u00e3o: Discuta com seus colegas as diferen\u00e7as entre vari\u00e1veis e constantes, e a import\u00e2ncia de definir o tipo de dado para cada elemento.","title":"Aula 1"},{"location":"aula1/#aula-1-prazer-compiladores-continuacao","text":"","title":"Aula 1 - Prazer, Compiladores! \ud83e\udd1d\ud83d\udc7e (Continua\u00e7\u00e3o)"},{"location":"aula1/#a-importancia-dos-compiladores","text":"Na primeira parte da aula, vimos que os compiladores s\u00e3o como tradutores que transformam c\u00f3digo escrito em uma linguagem de programa\u00e7\u00e3o (que humanos entendem) para uma linguagem que o computador entende (linguagem de m\u00e1quina). Imagine que voc\u00ea quer ensinar um amigo a fazer um bolo, mas ele s\u00f3 fala japon\u00eas. Voc\u00ea precisaria de um tradutor para transmitir as instru\u00e7\u00f5es corretamente, certo? \u00c9 exatamente isso que um compilador faz! Ele garante que o computador compreenda e execute as instru\u00e7\u00f5es do seu programa.","title":"A Import\u00e2ncia dos Compiladores"},{"location":"aula1/#governo-dos-states-pede-para-parar-de-utilizar-c-e-assembly","text":"","title":"Governo Dos States Pede para Parar de Utilizar C e Assembly"},{"location":"aula1/#fases-da-compilacao-uma-analise-detalhada","text":"","title":"Fases da Compila\u00e7\u00e3o: Uma An\u00e1lise Detalhada"},{"location":"aula1/#para-um-problema","text":"A compila\u00e7\u00e3o, como vimos, \u00e9 um processo dividido em etapas. Vamos entender melhor as tr\u00eas principais: An\u00e1lise L\u00e9xica (Fase do \"dicion\u00e1rio\"): Nesta fase, o compilador age como um leitor que examina o c\u00f3digo letra por letra, agrupando-as em \"palavras\" com significado para a linguagem, como nomes de vari\u00e1veis, palavras-chave (ex.: if , else , for ) e operadores (+, -, *, /). Imagine um corretor ortogr\u00e1fico verificando cada palavra e sinal de pontua\u00e7\u00e3o do seu texto.","title":"Para um problema:"},{"location":"aula1/#analise-lexica-e-expressoes-regulares","text":"A An\u00e1lise L\u00e9xica \u00e9 a primeira fase de um compilador, respons\u00e1vel por dividir o c\u00f3digo-fonte em uma sequ\u00eancia de tokens. Esses tokens representam as unidades b\u00e1sicas da linguagem, como palavras-chave, identificadores, n\u00fameros, operadores, entre outros. Para realizar a An\u00e1lise L\u00e9xica, uma t\u00e9cnica comumente utilizada s\u00e3o as express\u00f5es regulares (regex). As express\u00f5es regulares s\u00e3o padr\u00f5es que descrevem um conjunto de cadeias de caracteres. Elas permitem identificar e extrair partes espec\u00edficas de um texto com base em regras definidas. As express\u00f5es regulares s\u00e3o compostas por caracteres literais e metacaracteres. Alguns metacaracteres comuns incluem: . (ponto): Corresponde a qualquer caractere, exceto uma nova linha. * (asterisco): Corresponde a zero ou mais ocorr\u00eancias do caractere ou grupo anterior. + (mais): Corresponde a uma ou mais ocorr\u00eancias do caractere ou grupo anterior. ? (interroga\u00e7\u00e3o): Corresponde a zero ou uma ocorr\u00eancia do caractere ou grupo anterior. ^ (circunflexo): Corresponde ao in\u00edcio da linha. $ (cifr\u00e3o): Corresponde ao final da linha. [] (colchetes): Define um conjunto de caracteres. Por exemplo, [aeiou] corresponde a qualquer vogal. Al\u00e9m disso, existem classes de caracteres predefinidas, como: \\d : Corresponde a qualquer d\u00edgito (0-9). \\w : Corresponde a qualquer caractere alfanum\u00e9rico (letra ou d\u00edgito). \\s : Corresponde a qualquer caractere de espa\u00e7o em branco (espa\u00e7o, tabula\u00e7\u00e3o, nova linha). Exemplo de express\u00e3o regular para identificar n\u00fameros inteiros: import re # Express\u00e3o regular para n\u00fameros inteiros pattern = r'\\d+' # Texto de exemplo text = \"Eu tenho 25 anos e meu irm\u00e3o tem 30 anos.\" # Encontrar todos os n\u00fameros inteiros no texto matches = re.findall(pattern, text) # Imprimir os n\u00fameros encontrados for match in matches: print(match) Nesse exemplo, a express\u00e3o regular \\d+ \u00e9 usada para encontrar n\u00fameros inteiros no texto. O m\u00e9todo re.findall() \u00e9 utilizado para encontrar todas as ocorr\u00eancias da express\u00e3o regular no texto. O resultado ser\u00e1: 25 30 As express\u00f5es regulares s\u00e3o uma ferramenta poderosa para a An\u00e1lise L\u00e9xica, permitindo identificar e extrair tokens espec\u00edficos do c\u00f3digo-fonte. Elas podem ser combinadas com outras t\u00e9cnicas, como aut\u00f4matos finitos, para construir um analisador l\u00e9xico completo. No entanto, \u00e9 importante ressaltar que as express\u00f5es regulares t\u00eam suas limita\u00e7\u00f5es. Elas s\u00e3o adequadas para identificar padr\u00f5es simples e regulares, mas podem se tornar complexas e dif\u00edceis de manter para linguagens com estruturas mais complexas. Nesses casos, outras t\u00e9cnicas, como a an\u00e1lise sint\u00e1tica, s\u00e3o necess\u00e1rias para lidar com a estrutura hier\u00e1rquica do c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica (Fase da \"gram\u00e1tica\"): Com as \"palavras\" identificadas, o compilador verifica se elas est\u00e3o organizadas de forma correta, seguindo as regras gramaticais da linguagem. \u00c9 como analisar se a ordem das palavras em uma frase faz sentido. Por exemplo, em portugu\u00eas, dizemos \"O gato comeu o peixe\", e n\u00e3o \"Comeu peixe o gato o\".","title":"An\u00e1lise L\u00e9xica e Express\u00f5es Regulares"},{"location":"aula1/#analise-sintatica","text":"A An\u00e1lise Sint\u00e1tica \u00e9 a segunda fase de um compilador, que ocorre ap\u00f3s a An\u00e1lise L\u00e9xica. Seu objetivo \u00e9 verificar se a sequ\u00eancia de tokens gerada pela An\u00e1lise L\u00e9xica est\u00e1 de acordo com as regras gramaticais da linguagem de programa\u00e7\u00e3o. Em outras palavras, a An\u00e1lise Sint\u00e1tica verifica se o c\u00f3digo-fonte possui uma estrutura v\u00e1lida. Durante a An\u00e1lise Sint\u00e1tica, o compilador constr\u00f3i uma representa\u00e7\u00e3o estruturada do c\u00f3digo-fonte, geralmente na forma de uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). A AST representa a estrutura hier\u00e1rquica do c\u00f3digo, mostrando a rela\u00e7\u00e3o entre os diferentes elementos da linguagem, como express\u00f5es, comandos e blocos de c\u00f3digo. Existem duas abordagens principais para a An\u00e1lise Sint\u00e1tica: An\u00e1lise Sint\u00e1tica Descendente (Top-Down Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir da regra gramatical mais geral e tenta derivar a sequ\u00eancia de tokens de entrada. O m\u00e9todo mais comum \u00e9 a an\u00e1lise preditiva recursiva, que utiliza recurs\u00e3o para percorrer a gram\u00e1tica e construir a AST. A an\u00e1lise descendente \u00e9 adequada para gram\u00e1ticas LL (Left-to-right, Leftmost derivation), onde \u00e9 poss\u00edvel escolher a regra correta a ser aplicada com base nos pr\u00f3ximos tokens de entrada. An\u00e1lise Sint\u00e1tica Ascendente (Bottom-Up Parsing): Nessa abordagem, a an\u00e1lise come\u00e7a a partir dos tokens de entrada e tenta reduzi-los \u00e0s regras gramaticais at\u00e9 chegar \u00e0 regra inicial. O m\u00e9todo mais comum \u00e9 o LR (Left-to-right, Rightmost derivation), que utiliza uma tabela de an\u00e1lise para determinar as a\u00e7\u00f5es a serem tomadas com base nos tokens de entrada. A an\u00e1lise ascendente \u00e9 adequada para gram\u00e1ticas mais complexas e amb\u00edguas, onde a escolha da regra correta depende dos tokens futuros. Exemplo de An\u00e1lise Sint\u00e1tica usando a abordagem descendente: def parse_expression(tokens): def parse_term(tokens): if tokens[0] == 'NUMBER': return ('NUMBER', tokens.pop(0)[1]) elif tokens[0] == 'LPAREN': tokens.pop(0) expr = parse_expression(tokens) if tokens.pop(0) != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") return expr def parse_factor(tokens): term = parse_term(tokens) while tokens and tokens[0] in ['MULTIPLY', 'DIVIDE']: op = tokens.pop(0) right = parse_term(tokens) term = (op, term, right) return term expr = parse_factor(tokens) while tokens and tokens[0] in ['PLUS', 'MINUS']: op = tokens.pop(0) right = parse_factor(tokens) expr = (op, expr, right) return expr Nesse exemplo, a fun\u00e7\u00e3o parse_expression realiza a an\u00e1lise sint\u00e1tica de uma express\u00e3o aritm\u00e9tica simples. Ela utiliza fun\u00e7\u00f5es auxiliares parse_term e parse_factor para lidar com os diferentes n\u00edveis de preced\u00eancia dos operadores. A an\u00e1lise \u00e9 feita de forma recursiva, consumindo os tokens de entrada e construindo a AST correspondente. A An\u00e1lise Sint\u00e1tica \u00e9 uma fase crucial do compilador, pois garante que o c\u00f3digo-fonte esteja estruturalmente correto antes de prosseguir para as pr\u00f3ximas etapas, como a An\u00e1lise Sem\u00e2ntica e a Gera\u00e7\u00e3o de C\u00f3digo. Ela tamb\u00e9m fornece informa\u00e7\u00f5es importantes sobre a estrutura do programa, que s\u00e3o usadas nas fases posteriores do processo de compila\u00e7\u00e3o. An\u00e1lise Sem\u00e2ntica (Fase da \"interpreta\u00e7\u00e3o\"): Ap\u00f3s a an\u00e1lise sint\u00e1tica, o compilador precisa entender o significado do c\u00f3digo. Ele verifica se as opera\u00e7\u00f5es fazem sentido, se as vari\u00e1veis foram declaradas corretamente e se os tipos de dados s\u00e3o compat\u00edveis. \u00c9 como analisar se as frases em um texto fazem sentido juntas e transmitem a mensagem desejada.","title":"An\u00e1lise Sint\u00e1tica"},{"location":"aula1/#funcionamento-de-um-compilador","text":"","title":"Funcionamento de um Compilador"},{"location":"aula1/#vamos-rodar-tudo-isso-em-python","text":"Aqui est\u00e1 um exemplo de programa em Python que demonstra as tr\u00eas fases principais de um compilador: an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica e an\u00e1lise sem\u00e2ntica. import re # Defini\u00e7\u00e3o dos tokens tokens = [ (r'\\d+', 'NUMBER'), (r'\\+', 'PLUS'), (r'\\-', 'MINUS'), (r'\\*', 'MULTIPLY'), (r'\\/', 'DIVIDE'), (r'\\(', 'LPAREN'), (r'\\)', 'RPAREN'), (r'\\s+', 'WHITESPACE') ] # An\u00e1lise L\u00e9xica def lexical_analysis(code): lexemes = [] while code: matched = False for token_expr, token_type in tokens: match = re.match(token_expr, code) if match: value = match.group() if token_type != 'WHITESPACE': lexemes.append((token_type, value)) code = code[len(value):] matched = True break if not matched: raise ValueError(f\"Lexema inv\u00e1lido: {code}\") return lexemes # An\u00e1lise Sint\u00e1tica def syntax_analysis(lexemes): ast = [] while lexemes: token_type, value = lexemes.pop(0) if token_type == 'NUMBER': ast.append(('NUMBER', int(value))) elif token_type in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: ast.append((token_type,)) elif token_type == 'LPAREN': sub_expr = syntax_analysis(lexemes) ast.append(('EXPR', sub_expr)) if lexemes.pop(0)[0] != 'RPAREN': raise ValueError(\"Par\u00eantese de fechamento ausente\") else: raise ValueError(f\"Token inesperado: {token_type}\") return ast # An\u00e1lise Sem\u00e2ntica def semantic_analysis(ast): if isinstance(ast, tuple): if ast[0] == 'NUMBER': return ast[1] elif ast[0] in ['PLUS', 'MINUS', 'MULTIPLY', 'DIVIDE']: return ast[0] elif ast[0] == 'EXPR': return semantic_analysis(ast[1]) elif isinstance(ast, list): if len(ast) != 3: raise ValueError(\"Express\u00e3o inv\u00e1lida\") left = semantic_analysis(ast[0]) op = semantic_analysis(ast[1]) right = semantic_analysis(ast[2]) if not isinstance(left, int) or not isinstance(right, int): raise ValueError(\"Operandos inv\u00e1lidos\") if op == 'PLUS': return left + right elif op == 'MINUS': return left - right elif op == 'MULTIPLY': return left * right elif op == 'DIVIDE': if right == 0: raise ValueError(\"Divis\u00e3o por zero\") return left // right # Exemplo de uso code = \"2 + (3 * 4) - 5\" print(\"C\u00f3digo fonte:\", code) lexemes = lexical_analysis(code) print(\"An\u00e1lise L\u00e9xica:\", lexemes) ast = syntax_analysis(lexemes) print(\"An\u00e1lise Sint\u00e1tica:\", ast) result = semantic_analysis(ast) print(\"An\u00e1lise Sem\u00e2ntica:\", result) Explica\u00e7\u00e3o do programa: An\u00e1lise L\u00e9xica: Definimos os tokens que o compilador reconhecer\u00e1, como n\u00fameros, operadores e par\u00eanteses. A fun\u00e7\u00e3o lexical_analysis recebe o c\u00f3digo-fonte como entrada e retorna uma lista de lexemas (tokens) encontrados no c\u00f3digo. Utilizamos express\u00f5es regulares para identificar os tokens no c\u00f3digo-fonte. An\u00e1lise Sint\u00e1tica: A fun\u00e7\u00e3o syntax_analysis recebe a lista de lexemas como entrada e constr\u00f3i uma \u00e1rvore de an\u00e1lise sint\u00e1tica (AST - Abstract Syntax Tree). Percorremos os lexemas e constru\u00edmos a AST com base na estrutura da express\u00e3o. Tratamos par\u00eanteses aninhados recursivamente. An\u00e1lise Sem\u00e2ntica: A fun\u00e7\u00e3o semantic_analysis recebe a AST como entrada e realiza a an\u00e1lise sem\u00e2ntica. Percorremos a AST recursivamente e avaliamos a express\u00e3o de acordo com as regras sem\u00e2nticas. Verificamos se os operandos s\u00e3o v\u00e1lidos e realizamos as opera\u00e7\u00f5es aritm\u00e9ticas correspondentes. No exemplo de uso, fornecemos um c\u00f3digo-fonte simples \"2 + (3 * 4) - 5\" e aplicamos as tr\u00eas fases do compilador: 1. An\u00e1lise L\u00e9xica: Obtemos a lista de lexemas. 2. An\u00e1lise Sint\u00e1tica: Constru\u00edmos a AST a partir dos lexemas. 3. An\u00e1lise Sem\u00e2ntica: Avaliamos a express\u00e3o e obtemos o resultado final. Esse programa \u00e9 uma simplifica\u00e7\u00e3o das fases de um compilador e serve para ilustrar os conceitos b\u00e1sicos envolvidos em cada fase. Em um compilador real, essas fases s\u00e3o mais complexas e envolvem mais etapas e detalhes.","title":"Vamos rodar tudo isso em Python!"},{"location":"aula1/#a-tabela-de-simbolos-organizando-a-informacao","text":"A tabela de s\u00edmbolos \u00e9 como um dicion\u00e1rio que o compilador utiliza para armazenar e organizar informa\u00e7\u00f5es sobre todos os elementos do seu c\u00f3digo, como vari\u00e1veis, fun\u00e7\u00f5es e classes. Imagine que voc\u00ea est\u00e1 organizando uma festa e precisa controlar uma lista de convidados. Para cada convidado, voc\u00ea anota seu nome, n\u00famero de telefone e se ele confirmou presen\u00e7a. A tabela de s\u00edmbolos funciona de maneira similar, guardando informa\u00e7\u00f5es importantes sobre cada elemento do seu c\u00f3digo.","title":"A Tabela de S\u00edmbolos: Organizando a Informa\u00e7\u00e3o"},{"location":"aula1/#atividade-em-sala-de-aula","text":"Objetivo: Compreender a import\u00e2ncia do Debbuging! Enunciado: Sabe o c\u00f3digo mais acima sobre compila\u00e7\u00e3o em python? Pois \u00e9, ele est\u00e1 quebrado, a sua miss\u00e3o \u00e9 ajustar o c\u00f3digo! Observa\u00e7\u00e3o: Discuta com seus colegas as diferen\u00e7as entre vari\u00e1veis e constantes, e a import\u00e2ncia de definir o tipo de dado para cada elemento.","title":"Atividade em Sala de Aula"},{"location":"aula2/","text":"Aula 2 - Compila\u00e7\u00e3o e Intera\u00e7\u00e3o: Do C\u00f3digo ao Execut\u00e1vel \ud83d\udcbb\ud83d\udd27 No fascinante mundo da programa\u00e7\u00e3o, as linguagens de programa\u00e7\u00e3o e as linguagens de m\u00e1quina desempenham pap\u00e9is fundamentais na cria\u00e7\u00e3o de software. Embora ambas sejam inven\u00e7\u00f5es humanas, as linguagens de programa\u00e7\u00e3o oferecem uma compreens\u00e3o mais acess\u00edvel, utilizando auxiliares mnem\u00f4nicos e a\u00e7\u00facar sint\u00e1tico para facilitar o processo de desenvolvimento. Por outro lado, a linguagem de m\u00e1quina \u00e9 representada por um arquivo bin\u00e1rio complexo, de dif\u00edcil compreens\u00e3o para os programadores. O que \u00e9 Assembly? \ud83e\udd14 Assembly \u00e9 uma linguagem de baixo n\u00edvel que serve como uma representa\u00e7\u00e3o leg\u00edvel por humanos das instru\u00e7\u00f5es de linguagem de m\u00e1quina. Ela fornece uma abstra\u00e7\u00e3o mais pr\u00f3xima do hardware, permitindo aos programadores um controle mais direto sobre o comportamento do processador. No entanto, escrever c\u00f3digo em Assembly pode ser uma tarefa \u00e1rdua e propensa a erros, especialmente em projetos de grande escala. Diferen\u00e7as entre Compila\u00e7\u00e3o e Interpreta\u00e7\u00e3o \u2696\ufe0f Existem duas abordagens principais para processar o c\u00f3digo-fonte e execut\u00e1-lo em um computador: compila\u00e7\u00e3o e interpreta\u00e7\u00e3o. Vamos explorar as diferen\u00e7as entre essas duas t\u00e9cnicas: Caracter\u00edstica Compila\u00e7\u00e3o Interpreta\u00e7\u00e3o Velocidade de execu\u00e7\u00e3o R\u00e1pida Mais lenta Consumo de recursos Menor Maior Portabilidade Espec\u00edfica da plataforma Independente da plataforma Detec\u00e7\u00e3o de erros Durante a compila\u00e7\u00e3o Durante a execu\u00e7\u00e3o Exemplo de linguagens C, C++, Rust Python, JavaScript, Ruby \ud83d\udd14 \u00c9 importante ressaltar que o c\u00f3digo-fonte processado por meio de interpreta\u00e7\u00e3o oferece maior flexibilidade e facilidade no processo de programa\u00e7\u00e3o. No entanto, essa abordagem consome uma quantidade maior de recursos computacionais e resulta em uma execu\u00e7\u00e3o mais lenta em compara\u00e7\u00e3o com o c\u00f3digo compilado. \u2757 Consumo de Energia: Rust vs. Python \ud83d\udd0b Ao comparar linguagens compiladas e interpretadas, um aspecto interessante a ser considerado \u00e9 o consumo de energia. Vamos analisar a diferen\u00e7a entre Rust, uma linguagem compilada, e Python, uma linguagem interpretada: +---------------+---------------+ | Linguagem | Consumo de | | | Energia | +---------------+---------------+ | Rust | Baixo | +---------------+---------------+ | Python | Alto | +---------------+---------------+ Rust, sendo uma linguagem compilada, \u00e9 conhecida por sua efici\u00eancia energ\u00e9tica. O c\u00f3digo Rust \u00e9 compilado diretamente para instru\u00e7\u00f5es de m\u00e1quina otimizadas, resultando em um consumo de energia menor durante a execu\u00e7\u00e3o. Por outro lado, Python, sendo uma linguagem interpretada, requer a presen\u00e7a de um interpretador para executar o c\u00f3digo. Esse processo adicional de interpreta\u00e7\u00e3o consome mais energia em compara\u00e7\u00e3o com a execu\u00e7\u00e3o direta do c\u00f3digo compilado. Portanto, se a efici\u00eancia energ\u00e9tica for uma preocupa\u00e7\u00e3o crucial para o seu projeto, optar por uma linguagem compilada como Rust pode ser uma escolha mais adequada. Demonstra\u00e7\u00e3o Pr\u00e1tica Tutorial: Instala\u00e7\u00e3o do SDK do .NET 8 e Cria\u00e7\u00e3o de um Projeto MVC \ud83d\ude80 Neste tutorial, vamos aprender como instalar o SDK do .NET 8, criar um novo projeto MVC usando o comando dotnet new mvc e explorar o processo de compila\u00e7\u00e3o. Tamb\u00e9m faremos uma modifica\u00e7\u00e3o no c\u00f3digo para quebrar a compila\u00e7\u00e3o e, em seguida, corrigiremos o c\u00f3digo para que a compila\u00e7\u00e3o seja conclu\u00edda com sucesso. Passo 1: Instala\u00e7\u00e3o do SDK do .NET 8 \ud83d\udce5 Antes de come\u00e7armos, certifique-se de ter o SDK do .NET 8 instalado em seu sistema. Voc\u00ea pode baixar o SDK do .NET 8 a partir do site oficial da Microsoft: Download .NET 8 SDK Siga as instru\u00e7\u00f5es de instala\u00e7\u00e3o espec\u00edficas para o seu sistema operacional. Passo 2: Cria\u00e7\u00e3o de um Novo Projeto MVC \ud83c\udd95 Abra o terminal ou prompt de comando e navegue at\u00e9 o diret\u00f3rio onde deseja criar o projeto. Em seguida, execute o seguinte comando para criar um novo projeto MVC: dotnet new mvc -o MeuProjetoMVC Isso criar\u00e1 uma nova pasta chamada \"MeuProjetoMVC\" contendo a estrutura b\u00e1sica de um projeto MVC. Passo 3: Compila\u00e7\u00e3o do Projeto \u2699\ufe0f Navegue para o diret\u00f3rio do projeto rec\u00e9m-criado: cd MeuProjetoMVC Em seguida, execute o seguinte comando para compilar o projeto: dotnet build Se tudo estiver correto, a compila\u00e7\u00e3o ser\u00e1 conclu\u00edda com sucesso e voc\u00ea ver\u00e1 uma mensagem semelhante a esta: Build succeeded. 0 Warning(s) 0 Error(s) Passo 4: Quebrando a Compila\u00e7\u00e3o \ud83d\udca5 Agora, vamos fazer uma modifica\u00e7\u00e3o no c\u00f3digo para quebrar a compila\u00e7\u00e3o. Abra o arquivo Controllers/HomeController.cs em um editor de texto e adicione um erro de sintaxe intencional. Por exemplo, remova um ponto e v\u00edrgula ( ; ) no final de uma linha. Salve o arquivo e execute novamente o comando dotnet build . Desta vez, a compila\u00e7\u00e3o falhar\u00e1 e voc\u00ea ver\u00e1 uma mensagem de erro indicando o problema: Build failed. 1 Error(s) A mensagem de erro fornecer\u00e1 detalhes sobre o erro de sintaxe que voc\u00ea introduziu. Passo 5: Corrigindo o C\u00f3digo \ud83d\udd27 Agora, vamos corrigir o c\u00f3digo para que a compila\u00e7\u00e3o seja conclu\u00edda com sucesso. Abra novamente o arquivo Controllers/HomeController.cs e corrija o erro de sintaxe que voc\u00ea introduziu anteriormente. Salve o arquivo e execute novamente o comando dotnet build . Desta vez, a compila\u00e7\u00e3o ser\u00e1 conclu\u00edda com sucesso. Principais Livros de Compila\u00e7\u00e3o Claro! Aqui est\u00e1 um resumo dos principais livros sobre compila\u00e7\u00e3o e compiladores, que s\u00e3o essenciais para quem deseja aprofundar seus conhecimentos nessa \u00e1rea: 1. \"Compilers: Principles, Techniques, and Tools\" (Dragon Book) Autores: Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman Resumo: Conhecido como o \"Dragon Book\" devido \u00e0 ilustra\u00e7\u00e3o de um drag\u00e3o na capa, este livro \u00e9 considerado a b\u00edblia dos compiladores. Ele cobre todos os aspectos fundamentais da constru\u00e7\u00e3o de compiladores, incluindo an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica, an\u00e1lise sem\u00e2ntica, otimiza\u00e7\u00e3o de c\u00f3digo, gera\u00e7\u00e3o de c\u00f3digo e t\u00e9cnicas de compila\u00e7\u00e3o avan\u00e7adas. \u00c9 amplamente utilizado em cursos universit\u00e1rios e \u00e9 uma refer\u00eancia essencial para qualquer pessoa interessada em compiladores. 2. \"Engineering a Compiler\" Autores: Keith D. Cooper, Linda Torczon Resumo: Este livro oferece uma abordagem pr\u00e1tica e detalhada para a engenharia de compiladores. Ele aborda os princ\u00edpios b\u00e1sicos e as t\u00e9cnicas avan\u00e7adas de constru\u00e7\u00e3o de compiladores, com \u00eanfase em exemplos pr\u00e1ticos e implementa\u00e7\u00f5es reais. \u00c9 ideal para estudantes e profissionais que desejam entender como os compiladores funcionam na pr\u00e1tica e como aplicar esses conhecimentos em projetos reais. 3. \"Modern Compiler Implementation in C/Java/ML\" Autor: Andrew W. Appel Resumo: Esta s\u00e9rie de livros, dispon\u00edvel em vers\u00f5es para C, Java e ML, fornece uma introdu\u00e7\u00e3o pr\u00e1tica \u00e0 implementa\u00e7\u00e3o de compiladores. Cada vers\u00e3o do livro \u00e9 adaptada para a linguagem de programa\u00e7\u00e3o espec\u00edfica, oferecendo exemplos e exerc\u00edcios pr\u00e1ticos. O livro cobre t\u00f3picos como an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica, gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio, otimiza\u00e7\u00e3o e gera\u00e7\u00e3o de c\u00f3digo final. \u00c9 uma excelente escolha para quem deseja aprender a implementar compiladores em uma linguagem espec\u00edfica. 4. \"Advanced Compiler Design and Implementation\" Autor: Steven Muchnick Resumo: Este livro \u00e9 voltado para leitores que j\u00e1 possuem um conhecimento b\u00e1sico sobre compiladores e desejam explorar t\u00e9cnicas avan\u00e7adas de design e implementa\u00e7\u00e3o. Ele cobre t\u00f3picos como otimiza\u00e7\u00e3o de c\u00f3digo, an\u00e1lise de depend\u00eancias, paralelismo, e t\u00e9cnicas de compila\u00e7\u00e3o para arquiteturas modernas. \u00c9 uma leitura essencial para quem deseja aprofundar seus conhecimentos e trabalhar em projetos de compiladores de alto desempenho. 5. \"The Definitive ANTLR 4 Reference\" Autor: Terence Parr Resumo: Este livro \u00e9 um guia completo para o ANTLR (Another Tool for Language Recognition), uma ferramenta popular para a constru\u00e7\u00e3o de analisadores l\u00e9xicos e sint\u00e1ticos. Ele fornece uma introdu\u00e7\u00e3o pr\u00e1tica ao uso do ANTLR, com exemplos detalhados e explica\u00e7\u00f5es claras. \u00c9 ideal para desenvolvedores que desejam criar linguagens de dom\u00ednio espec\u00edfico (DSLs) ou trabalhar com an\u00e1lise de linguagem. 6. \"Programming Language Pragmatics\" Autor: Michael L. Scott Resumo: Embora n\u00e3o seja exclusivamente sobre compiladores, este livro oferece uma vis\u00e3o abrangente sobre a teoria e a pr\u00e1tica das linguagens de programa\u00e7\u00e3o, incluindo a constru\u00e7\u00e3o de compiladores. Ele aborda t\u00f3picos como sem\u00e2ntica de linguagem, design de linguagem, e t\u00e9cnicas de implementa\u00e7\u00e3o. \u00c9 uma excelente leitura para entender o contexto mais amplo em que os compiladores operam. An\u00e1lise L\u00e9xica: Gera\u00e7\u00e3o de Tokens em Detalhes \ud83d\udd0d\ud83d\udcc4 Nesta aula, vamos explorar a an\u00e1lise l\u00e9xica e a gera\u00e7\u00e3o de tokens em detalhes, utilizando a linguagem de programa\u00e7\u00e3o Python. A an\u00e1lise l\u00e9xica \u00e9 a primeira fase do processo de compila\u00e7\u00e3o, onde o c\u00f3digo-fonte \u00e9 dividido em unidades menores chamadas tokens. O que s\u00e3o Tokens? \ud83c\udfab Tokens s\u00e3o unidades b\u00e1sicas de um programa que possuem um significado pr\u00f3prio. Eles podem ser palavras-chave, identificadores, literais, operadores ou s\u00edmbolos especiais. Cada token \u00e9 classificado de acordo com sua categoria l\u00e9xica. Exemplo de C\u00f3digo-Fonte \ud83d\udcbb Vou demonstrar como isso funciona com uma equa\u00e7\u00e3o simples em C#. Vamos considerar a seguinte equa\u00e7\u00e3o em C#: int result = 3 + 5 * (2 - 8); Passos da An\u00e1lise L\u00e9xica Entrada do C\u00f3digo-Fonte: csharp int result = 3 + 5 * (2 - 8); Divis\u00e3o em Tokens: A an\u00e1lise l\u00e9xica divide o c\u00f3digo-fonte em unidades menores chamadas tokens. Cada token representa uma unidade sint\u00e1tica do c\u00f3digo, como palavras-chave, identificadores, operadores, literais, etc. Tabela de Tokens: Aqui est\u00e1 a tabela de tokens gerada a partir da equa\u00e7\u00e3o acima: Token Tipo Descri\u00e7\u00e3o int Palavra-chave Tipo de dado inteiro result Identificador Nome da vari\u00e1vel = Operador Operador de atribui\u00e7\u00e3o 3 Literal N\u00famero inteiro + Operador Operador de adi\u00e7\u00e3o 5 Literal N\u00famero inteiro * Operador Operador de multiplica\u00e7\u00e3o ( Delimitador Par\u00eantese de abertura 2 Literal N\u00famero inteiro - Operador Operador de subtra\u00e7\u00e3o 8 Literal N\u00famero inteiro ) Delimitador Par\u00eantese de fechamento ; Delimitador Ponto e v\u00edrgula (fim da instru\u00e7\u00e3o) Explica\u00e7\u00e3o Detalhada Palavras-chave: S\u00e3o termos reservados pela linguagem de programa\u00e7\u00e3o. No exemplo, int \u00e9 uma palavra-chave que indica que a vari\u00e1vel result \u00e9 do tipo inteiro. Identificadores: S\u00e3o nomes dados a vari\u00e1veis, fun\u00e7\u00f5es, classes, etc. No exemplo, result \u00e9 um identificador. Operadores: S\u00e3o s\u00edmbolos que representam opera\u00e7\u00f5es. No exemplo, = , + , * , e - s\u00e3o operadores. Literais: S\u00e3o valores constantes diretamente representados no c\u00f3digo. No exemplo, 3 , 5 , 2 , e 8 s\u00e3o literais inteiros. Delimitadores: S\u00e3o caracteres que delimitam estruturas de c\u00f3digo. No exemplo, ( , ) , e ; s\u00e3o delimitadores. Palavras-chave: S\u00e3o termos reservados pela linguagem de programa\u00e7\u00e3o. No exemplo, int \u00e9 uma palavra-chave que indica que a vari\u00e1vel result \u00e9 do tipo inteiro. Identificadores: S\u00e3o nomes dados a vari\u00e1veis, fun\u00e7\u00f5es, classes, etc. No exemplo, result \u00e9 um identificador. Operadores: S\u00e3o s\u00edmbolos que representam opera\u00e7\u00f5es. No exemplo, = , + , * , e - s\u00e3o operadores. Literais: S\u00e3o valores constantes diretamente representados no c\u00f3digo. No exemplo, 3 , 5 , 2 , e 8 s\u00e3o literais inteiros. Delimitadores: S\u00e3o caracteres que delimitam estruturas de c\u00f3digo. No exemplo, ( , ) , e ; s\u00e3o delimitadores. Implementa\u00e7\u00e3o do Analisador L\u00e9xico em Python \ud83d\udc0d Agora, vamos implementar um analisador l\u00e9xico simples em Python para gerar os tokens a partir do c\u00f3digo-fonte acima. import re def tokenize(code): # Defini\u00e7\u00e3o das express\u00f5es regulares para cada tipo de token token_specs = [ ('KEYWORD', r'if|then|else|end|print'), ('IDENTIFIER', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('NUMBER', r'\\d+(\\.\\d+)?'), ('OPERATOR', r'[><=!+\\-*/%]'), ('STRING', r'\".*?\"'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('NEWLINE', r'\\n'), ('SKIP', r'[ \\t]+'), ] # Compila\u00e7\u00e3o das express\u00f5es regulares token_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs) regex = re.compile(token_regex) # Gera\u00e7\u00e3o dos tokens tokens = [] for match in regex.finditer(code): token_type = match.lastgroup token_value = match.group(token_type) if token_type != 'SKIP': tokens.append((token_type, token_value)) return tokens # C\u00f3digo-fonte de exemplo code = ''' if x > 10 then print(\"Hello, World!\") else print(\"x is less than or equal to 10\") end ''' # Chamada da fun\u00e7\u00e3o de tokeniza\u00e7\u00e3o tokens = tokenize(code) # Impress\u00e3o dos tokens gerados for token in tokens: print(token) Neste exemplo, utilizamos express\u00f5es regulares para definir os padr\u00f5es de cada tipo de token. Em seguida, compilamos essas express\u00f5es regulares em um \u00fanico padr\u00e3o usando o m\u00f3dulo re do Python. A fun\u00e7\u00e3o tokenize recebe o c\u00f3digo-fonte como entrada e itera sobre as correspond\u00eancias encontradas pelo padr\u00e3o de express\u00e3o regular. Para cada correspond\u00eancia, extra\u00edmos o tipo de token e seu valor. Ignoramos os tokens do tipo SKIP , que representam espa\u00e7os em branco e tabula\u00e7\u00f5es. Por fim, imprimimos os tokens gerados, que ser\u00e3o semelhantes a: ('KEYWORD', 'if') ('IDENTIFIER', 'x') ('OPERATOR', '>') ('NUMBER', '10') ('KEYWORD', 'then') ('KEYWORD', 'print') ('LPAREN', '(') ('STRING', '\"Hello, World!\"') ('RPAREN', ')') ('KEYWORD', 'else') ('KEYWORD', 'print') ('LPAREN', '(') ('STRING', '\"x is less than or equal to 10\"') ('RPAREN', ')') ('KEYWORD', 'end') Cada token \u00e9 representado por uma tupla contendo o tipo de token e seu valor correspondente. Vamos Brincar no Colab! Claro! Vamos refazer o exemplo anterior e criar uma tabela de s\u00edmbolos usando o pandas no Google Colab. Aqui est\u00e1 o c\u00f3digo atualizado: import re import pandas as pd def tokenize(code): # Defini\u00e7\u00e3o das express\u00f5es regulares para cada tipo de token token_specs = [ ('KEYWORD', r'if|then|else|end|print'), ('IDENTIFIER', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('NUMBER', r'\\d+(\\.\\d+)?'), ('OPERATOR', r'[><=!+\\-*/%]'), ('STRING', r'\".*?\"'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('NEWLINE', r'\\n'), ('SKIP', r'[ \\t]+'), ] # Compila\u00e7\u00e3o das express\u00f5es regulares token_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs) regex = re.compile(token_regex) # Gera\u00e7\u00e3o dos tokens tokens = [] for match in regex.finditer(code): token_type = match.lastgroup token_value = match.group(token_type) if token_type != 'SKIP': tokens.append((token_type, token_value)) return tokens # C\u00f3digo-fonte de exemplo code = ''' if x > 10 then print(\"Hello, World!\") else print(\"x is less than or equal to 10\") end ''' # Chamada da fun\u00e7\u00e3o de tokeniza\u00e7\u00e3o tokens = tokenize(code) # Cria\u00e7\u00e3o da tabela de s\u00edmbolos usando o pandas symbol_table = pd.DataFrame(tokens, columns=['Token Type', 'Token Value']) # Impress\u00e3o da tabela de s\u00edmbolos print(\"Tabela de S\u00edmbolos:\") print(symbol_table) Neste exemplo atualizado, utilizamos o pandas para criar uma tabela de s\u00edmbolos a partir dos tokens gerados. Ap\u00f3s chamar a fun\u00e7\u00e3o tokenize com o c\u00f3digo-fonte de exemplo, criamos um DataFrame do pandas chamado symbol_table usando os tokens como dados e especificando as colunas como \"Token Type\" e \"Token Value\". Por fim, imprimimos a tabela de s\u00edmbolos usando o m\u00e9todo print . Ao executar este c\u00f3digo no Google Colab, voc\u00ea ver\u00e1 a seguinte sa\u00edda: Tabela de S\u00edmbolos: Token Type Token Value 0 KEYWORD if 1 IDENTIFIER x 2 OPERATOR > 3 NUMBER 10 4 KEYWORD then 5 KEYWORD print 6 LPAREN ( 7 STRING \"Hello, World!\" 8 RPAREN ) 9 KEYWORD else 10 KEYWORD print 11 LPAREN ( 12 STRING \"x is less than or equal to 10\" 13 RPAREN ) 14 KEYWORD end A tabela de s\u00edmbolos exibe cada token encontrado no c\u00f3digo-fonte, juntamente com seu tipo de token correspondente. Conclus\u00e3o \ud83c\udf89 Compila\u00e7\u00e3o e interpreta\u00e7\u00e3o s\u00e3o duas abordagens distintas para processar o c\u00f3digo-fonte e execut\u00e1-lo em um computador. Enquanto a compila\u00e7\u00e3o oferece maior velocidade de execu\u00e7\u00e3o e menor consumo de recursos, a interpreta\u00e7\u00e3o proporciona maior flexibilidade e portabilidade. A escolha entre essas abordagens depende dos requisitos espec\u00edficos do projeto, levando em considera\u00e7\u00e3o fatores como desempenho, consumo de energia e facilidade de desenvolvimento. Ao compreender as diferen\u00e7as entre compila\u00e7\u00e3o e interpreta\u00e7\u00e3o, os programadores podem tomar decis\u00f5es informadas sobre qual abordagem adotar para seus projetos, buscando o equil\u00edbrio ideal entre efici\u00eancia e produtividade. \ud83d\ude80 Indica\u00e7\u00e3o de Livros: Link: Programa\u00e7\u00e3o Funcional e Concorrente em Rust Link: ASP.NET Core MVC","title":"Aula 2"},{"location":"aula2/#aula-2-compilacao-e-interacao-do-codigo-ao-executavel","text":"No fascinante mundo da programa\u00e7\u00e3o, as linguagens de programa\u00e7\u00e3o e as linguagens de m\u00e1quina desempenham pap\u00e9is fundamentais na cria\u00e7\u00e3o de software. Embora ambas sejam inven\u00e7\u00f5es humanas, as linguagens de programa\u00e7\u00e3o oferecem uma compreens\u00e3o mais acess\u00edvel, utilizando auxiliares mnem\u00f4nicos e a\u00e7\u00facar sint\u00e1tico para facilitar o processo de desenvolvimento. Por outro lado, a linguagem de m\u00e1quina \u00e9 representada por um arquivo bin\u00e1rio complexo, de dif\u00edcil compreens\u00e3o para os programadores.","title":"Aula 2 - Compila\u00e7\u00e3o e Intera\u00e7\u00e3o: Do C\u00f3digo ao Execut\u00e1vel \ud83d\udcbb\ud83d\udd27"},{"location":"aula2/#o-que-e-assembly","text":"Assembly \u00e9 uma linguagem de baixo n\u00edvel que serve como uma representa\u00e7\u00e3o leg\u00edvel por humanos das instru\u00e7\u00f5es de linguagem de m\u00e1quina. Ela fornece uma abstra\u00e7\u00e3o mais pr\u00f3xima do hardware, permitindo aos programadores um controle mais direto sobre o comportamento do processador. No entanto, escrever c\u00f3digo em Assembly pode ser uma tarefa \u00e1rdua e propensa a erros, especialmente em projetos de grande escala.","title":"O que \u00e9 Assembly? \ud83e\udd14"},{"location":"aula2/#diferencas-entre-compilacao-e-interpretacao","text":"Existem duas abordagens principais para processar o c\u00f3digo-fonte e execut\u00e1-lo em um computador: compila\u00e7\u00e3o e interpreta\u00e7\u00e3o. Vamos explorar as diferen\u00e7as entre essas duas t\u00e9cnicas: Caracter\u00edstica Compila\u00e7\u00e3o Interpreta\u00e7\u00e3o Velocidade de execu\u00e7\u00e3o R\u00e1pida Mais lenta Consumo de recursos Menor Maior Portabilidade Espec\u00edfica da plataforma Independente da plataforma Detec\u00e7\u00e3o de erros Durante a compila\u00e7\u00e3o Durante a execu\u00e7\u00e3o Exemplo de linguagens C, C++, Rust Python, JavaScript, Ruby \ud83d\udd14 \u00c9 importante ressaltar que o c\u00f3digo-fonte processado por meio de interpreta\u00e7\u00e3o oferece maior flexibilidade e facilidade no processo de programa\u00e7\u00e3o. No entanto, essa abordagem consome uma quantidade maior de recursos computacionais e resulta em uma execu\u00e7\u00e3o mais lenta em compara\u00e7\u00e3o com o c\u00f3digo compilado. \u2757","title":"Diferen\u00e7as entre Compila\u00e7\u00e3o e Interpreta\u00e7\u00e3o \u2696\ufe0f"},{"location":"aula2/#consumo-de-energia-rust-vs-python","text":"Ao comparar linguagens compiladas e interpretadas, um aspecto interessante a ser considerado \u00e9 o consumo de energia. Vamos analisar a diferen\u00e7a entre Rust, uma linguagem compilada, e Python, uma linguagem interpretada: +---------------+---------------+ | Linguagem | Consumo de | | | Energia | +---------------+---------------+ | Rust | Baixo | +---------------+---------------+ | Python | Alto | +---------------+---------------+ Rust, sendo uma linguagem compilada, \u00e9 conhecida por sua efici\u00eancia energ\u00e9tica. O c\u00f3digo Rust \u00e9 compilado diretamente para instru\u00e7\u00f5es de m\u00e1quina otimizadas, resultando em um consumo de energia menor durante a execu\u00e7\u00e3o. Por outro lado, Python, sendo uma linguagem interpretada, requer a presen\u00e7a de um interpretador para executar o c\u00f3digo. Esse processo adicional de interpreta\u00e7\u00e3o consome mais energia em compara\u00e7\u00e3o com a execu\u00e7\u00e3o direta do c\u00f3digo compilado. Portanto, se a efici\u00eancia energ\u00e9tica for uma preocupa\u00e7\u00e3o crucial para o seu projeto, optar por uma linguagem compilada como Rust pode ser uma escolha mais adequada.","title":"Consumo de Energia: Rust vs. Python \ud83d\udd0b"},{"location":"aula2/#demonstracao-pratica","text":"","title":"Demonstra\u00e7\u00e3o Pr\u00e1tica"},{"location":"aula2/#tutorial-instalacao-do-sdk-do-net-8-e-criacao-de-um-projeto-mvc","text":"Neste tutorial, vamos aprender como instalar o SDK do .NET 8, criar um novo projeto MVC usando o comando dotnet new mvc e explorar o processo de compila\u00e7\u00e3o. Tamb\u00e9m faremos uma modifica\u00e7\u00e3o no c\u00f3digo para quebrar a compila\u00e7\u00e3o e, em seguida, corrigiremos o c\u00f3digo para que a compila\u00e7\u00e3o seja conclu\u00edda com sucesso.","title":"Tutorial: Instala\u00e7\u00e3o do SDK do .NET 8 e Cria\u00e7\u00e3o de um Projeto MVC \ud83d\ude80"},{"location":"aula2/#passo-1-instalacao-do-sdk-do-net-8","text":"Antes de come\u00e7armos, certifique-se de ter o SDK do .NET 8 instalado em seu sistema. Voc\u00ea pode baixar o SDK do .NET 8 a partir do site oficial da Microsoft: Download .NET 8 SDK Siga as instru\u00e7\u00f5es de instala\u00e7\u00e3o espec\u00edficas para o seu sistema operacional.","title":"Passo 1: Instala\u00e7\u00e3o do SDK do .NET 8 \ud83d\udce5"},{"location":"aula2/#passo-2-criacao-de-um-novo-projeto-mvc","text":"Abra o terminal ou prompt de comando e navegue at\u00e9 o diret\u00f3rio onde deseja criar o projeto. Em seguida, execute o seguinte comando para criar um novo projeto MVC: dotnet new mvc -o MeuProjetoMVC Isso criar\u00e1 uma nova pasta chamada \"MeuProjetoMVC\" contendo a estrutura b\u00e1sica de um projeto MVC.","title":"Passo 2: Cria\u00e7\u00e3o de um Novo Projeto MVC \ud83c\udd95"},{"location":"aula2/#passo-3-compilacao-do-projeto","text":"Navegue para o diret\u00f3rio do projeto rec\u00e9m-criado: cd MeuProjetoMVC Em seguida, execute o seguinte comando para compilar o projeto: dotnet build Se tudo estiver correto, a compila\u00e7\u00e3o ser\u00e1 conclu\u00edda com sucesso e voc\u00ea ver\u00e1 uma mensagem semelhante a esta: Build succeeded. 0 Warning(s) 0 Error(s)","title":"Passo 3: Compila\u00e7\u00e3o do Projeto \u2699\ufe0f"},{"location":"aula2/#passo-4-quebrando-a-compilacao","text":"Agora, vamos fazer uma modifica\u00e7\u00e3o no c\u00f3digo para quebrar a compila\u00e7\u00e3o. Abra o arquivo Controllers/HomeController.cs em um editor de texto e adicione um erro de sintaxe intencional. Por exemplo, remova um ponto e v\u00edrgula ( ; ) no final de uma linha. Salve o arquivo e execute novamente o comando dotnet build . Desta vez, a compila\u00e7\u00e3o falhar\u00e1 e voc\u00ea ver\u00e1 uma mensagem de erro indicando o problema: Build failed. 1 Error(s) A mensagem de erro fornecer\u00e1 detalhes sobre o erro de sintaxe que voc\u00ea introduziu.","title":"Passo 4: Quebrando a Compila\u00e7\u00e3o \ud83d\udca5"},{"location":"aula2/#passo-5-corrigindo-o-codigo","text":"Agora, vamos corrigir o c\u00f3digo para que a compila\u00e7\u00e3o seja conclu\u00edda com sucesso. Abra novamente o arquivo Controllers/HomeController.cs e corrija o erro de sintaxe que voc\u00ea introduziu anteriormente. Salve o arquivo e execute novamente o comando dotnet build . Desta vez, a compila\u00e7\u00e3o ser\u00e1 conclu\u00edda com sucesso.","title":"Passo 5: Corrigindo o C\u00f3digo \ud83d\udd27"},{"location":"aula2/#principais-livros-de-compilacao","text":"Claro! Aqui est\u00e1 um resumo dos principais livros sobre compila\u00e7\u00e3o e compiladores, que s\u00e3o essenciais para quem deseja aprofundar seus conhecimentos nessa \u00e1rea:","title":"Principais Livros de Compila\u00e7\u00e3o"},{"location":"aula2/#1-compilers-principles-techniques-and-tools-dragon-book","text":"Autores: Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman","title":"1. \"Compilers: Principles, Techniques, and Tools\" (Dragon Book)"},{"location":"aula2/#resumo","text":"Conhecido como o \"Dragon Book\" devido \u00e0 ilustra\u00e7\u00e3o de um drag\u00e3o na capa, este livro \u00e9 considerado a b\u00edblia dos compiladores. Ele cobre todos os aspectos fundamentais da constru\u00e7\u00e3o de compiladores, incluindo an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica, an\u00e1lise sem\u00e2ntica, otimiza\u00e7\u00e3o de c\u00f3digo, gera\u00e7\u00e3o de c\u00f3digo e t\u00e9cnicas de compila\u00e7\u00e3o avan\u00e7adas. \u00c9 amplamente utilizado em cursos universit\u00e1rios e \u00e9 uma refer\u00eancia essencial para qualquer pessoa interessada em compiladores.","title":"Resumo:"},{"location":"aula2/#2-engineering-a-compiler","text":"Autores: Keith D. Cooper, Linda Torczon","title":"2. \"Engineering a Compiler\""},{"location":"aula2/#resumo_1","text":"Este livro oferece uma abordagem pr\u00e1tica e detalhada para a engenharia de compiladores. Ele aborda os princ\u00edpios b\u00e1sicos e as t\u00e9cnicas avan\u00e7adas de constru\u00e7\u00e3o de compiladores, com \u00eanfase em exemplos pr\u00e1ticos e implementa\u00e7\u00f5es reais. \u00c9 ideal para estudantes e profissionais que desejam entender como os compiladores funcionam na pr\u00e1tica e como aplicar esses conhecimentos em projetos reais.","title":"Resumo:"},{"location":"aula2/#3-modern-compiler-implementation-in-cjavaml","text":"Autor: Andrew W. Appel","title":"3. \"Modern Compiler Implementation in C/Java/ML\""},{"location":"aula2/#resumo_2","text":"Esta s\u00e9rie de livros, dispon\u00edvel em vers\u00f5es para C, Java e ML, fornece uma introdu\u00e7\u00e3o pr\u00e1tica \u00e0 implementa\u00e7\u00e3o de compiladores. Cada vers\u00e3o do livro \u00e9 adaptada para a linguagem de programa\u00e7\u00e3o espec\u00edfica, oferecendo exemplos e exerc\u00edcios pr\u00e1ticos. O livro cobre t\u00f3picos como an\u00e1lise l\u00e9xica, an\u00e1lise sint\u00e1tica, gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio, otimiza\u00e7\u00e3o e gera\u00e7\u00e3o de c\u00f3digo final. \u00c9 uma excelente escolha para quem deseja aprender a implementar compiladores em uma linguagem espec\u00edfica.","title":"Resumo:"},{"location":"aula2/#4-advanced-compiler-design-and-implementation","text":"Autor: Steven Muchnick","title":"4. \"Advanced Compiler Design and Implementation\""},{"location":"aula2/#resumo_3","text":"Este livro \u00e9 voltado para leitores que j\u00e1 possuem um conhecimento b\u00e1sico sobre compiladores e desejam explorar t\u00e9cnicas avan\u00e7adas de design e implementa\u00e7\u00e3o. Ele cobre t\u00f3picos como otimiza\u00e7\u00e3o de c\u00f3digo, an\u00e1lise de depend\u00eancias, paralelismo, e t\u00e9cnicas de compila\u00e7\u00e3o para arquiteturas modernas. \u00c9 uma leitura essencial para quem deseja aprofundar seus conhecimentos e trabalhar em projetos de compiladores de alto desempenho.","title":"Resumo:"},{"location":"aula2/#5-the-definitive-antlr-4-reference","text":"Autor: Terence Parr","title":"5. \"The Definitive ANTLR 4 Reference\""},{"location":"aula2/#resumo_4","text":"Este livro \u00e9 um guia completo para o ANTLR (Another Tool for Language Recognition), uma ferramenta popular para a constru\u00e7\u00e3o de analisadores l\u00e9xicos e sint\u00e1ticos. Ele fornece uma introdu\u00e7\u00e3o pr\u00e1tica ao uso do ANTLR, com exemplos detalhados e explica\u00e7\u00f5es claras. \u00c9 ideal para desenvolvedores que desejam criar linguagens de dom\u00ednio espec\u00edfico (DSLs) ou trabalhar com an\u00e1lise de linguagem.","title":"Resumo:"},{"location":"aula2/#6-programming-language-pragmatics","text":"Autor: Michael L. Scott","title":"6. \"Programming Language Pragmatics\""},{"location":"aula2/#resumo_5","text":"Embora n\u00e3o seja exclusivamente sobre compiladores, este livro oferece uma vis\u00e3o abrangente sobre a teoria e a pr\u00e1tica das linguagens de programa\u00e7\u00e3o, incluindo a constru\u00e7\u00e3o de compiladores. Ele aborda t\u00f3picos como sem\u00e2ntica de linguagem, design de linguagem, e t\u00e9cnicas de implementa\u00e7\u00e3o. \u00c9 uma excelente leitura para entender o contexto mais amplo em que os compiladores operam.","title":"Resumo:"},{"location":"aula2/#analise-lexica-geracao-de-tokens-em-detalhes","text":"Nesta aula, vamos explorar a an\u00e1lise l\u00e9xica e a gera\u00e7\u00e3o de tokens em detalhes, utilizando a linguagem de programa\u00e7\u00e3o Python. A an\u00e1lise l\u00e9xica \u00e9 a primeira fase do processo de compila\u00e7\u00e3o, onde o c\u00f3digo-fonte \u00e9 dividido em unidades menores chamadas tokens.","title":"An\u00e1lise L\u00e9xica: Gera\u00e7\u00e3o de Tokens em Detalhes \ud83d\udd0d\ud83d\udcc4"},{"location":"aula2/#o-que-sao-tokens","text":"Tokens s\u00e3o unidades b\u00e1sicas de um programa que possuem um significado pr\u00f3prio. Eles podem ser palavras-chave, identificadores, literais, operadores ou s\u00edmbolos especiais. Cada token \u00e9 classificado de acordo com sua categoria l\u00e9xica.","title":"O que s\u00e3o Tokens? \ud83c\udfab"},{"location":"aula2/#exemplo-de-codigo-fonte","text":"Vou demonstrar como isso funciona com uma equa\u00e7\u00e3o simples em C#. Vamos considerar a seguinte equa\u00e7\u00e3o em C#: int result = 3 + 5 * (2 - 8);","title":"Exemplo de C\u00f3digo-Fonte \ud83d\udcbb"},{"location":"aula2/#passos-da-analise-lexica","text":"Entrada do C\u00f3digo-Fonte: csharp int result = 3 + 5 * (2 - 8); Divis\u00e3o em Tokens: A an\u00e1lise l\u00e9xica divide o c\u00f3digo-fonte em unidades menores chamadas tokens. Cada token representa uma unidade sint\u00e1tica do c\u00f3digo, como palavras-chave, identificadores, operadores, literais, etc. Tabela de Tokens: Aqui est\u00e1 a tabela de tokens gerada a partir da equa\u00e7\u00e3o acima: Token Tipo Descri\u00e7\u00e3o int Palavra-chave Tipo de dado inteiro result Identificador Nome da vari\u00e1vel = Operador Operador de atribui\u00e7\u00e3o 3 Literal N\u00famero inteiro + Operador Operador de adi\u00e7\u00e3o 5 Literal N\u00famero inteiro * Operador Operador de multiplica\u00e7\u00e3o ( Delimitador Par\u00eantese de abertura 2 Literal N\u00famero inteiro - Operador Operador de subtra\u00e7\u00e3o 8 Literal N\u00famero inteiro ) Delimitador Par\u00eantese de fechamento ; Delimitador Ponto e v\u00edrgula (fim da instru\u00e7\u00e3o)","title":"Passos da An\u00e1lise L\u00e9xica"},{"location":"aula2/#explicacao-detalhada","text":"Palavras-chave: S\u00e3o termos reservados pela linguagem de programa\u00e7\u00e3o. No exemplo, int \u00e9 uma palavra-chave que indica que a vari\u00e1vel result \u00e9 do tipo inteiro. Identificadores: S\u00e3o nomes dados a vari\u00e1veis, fun\u00e7\u00f5es, classes, etc. No exemplo, result \u00e9 um identificador. Operadores: S\u00e3o s\u00edmbolos que representam opera\u00e7\u00f5es. No exemplo, = , + , * , e - s\u00e3o operadores. Literais: S\u00e3o valores constantes diretamente representados no c\u00f3digo. No exemplo, 3 , 5 , 2 , e 8 s\u00e3o literais inteiros. Delimitadores: S\u00e3o caracteres que delimitam estruturas de c\u00f3digo. No exemplo, ( , ) , e ; s\u00e3o delimitadores. Palavras-chave: S\u00e3o termos reservados pela linguagem de programa\u00e7\u00e3o. No exemplo, int \u00e9 uma palavra-chave que indica que a vari\u00e1vel result \u00e9 do tipo inteiro. Identificadores: S\u00e3o nomes dados a vari\u00e1veis, fun\u00e7\u00f5es, classes, etc. No exemplo, result \u00e9 um identificador. Operadores: S\u00e3o s\u00edmbolos que representam opera\u00e7\u00f5es. No exemplo, = , + , * , e - s\u00e3o operadores. Literais: S\u00e3o valores constantes diretamente representados no c\u00f3digo. No exemplo, 3 , 5 , 2 , e 8 s\u00e3o literais inteiros. Delimitadores: S\u00e3o caracteres que delimitam estruturas de c\u00f3digo. No exemplo, ( , ) , e ; s\u00e3o delimitadores.","title":"Explica\u00e7\u00e3o Detalhada"},{"location":"aula2/#implementacao-do-analisador-lexico-em-python","text":"Agora, vamos implementar um analisador l\u00e9xico simples em Python para gerar os tokens a partir do c\u00f3digo-fonte acima. import re def tokenize(code): # Defini\u00e7\u00e3o das express\u00f5es regulares para cada tipo de token token_specs = [ ('KEYWORD', r'if|then|else|end|print'), ('IDENTIFIER', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('NUMBER', r'\\d+(\\.\\d+)?'), ('OPERATOR', r'[><=!+\\-*/%]'), ('STRING', r'\".*?\"'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('NEWLINE', r'\\n'), ('SKIP', r'[ \\t]+'), ] # Compila\u00e7\u00e3o das express\u00f5es regulares token_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs) regex = re.compile(token_regex) # Gera\u00e7\u00e3o dos tokens tokens = [] for match in regex.finditer(code): token_type = match.lastgroup token_value = match.group(token_type) if token_type != 'SKIP': tokens.append((token_type, token_value)) return tokens # C\u00f3digo-fonte de exemplo code = ''' if x > 10 then print(\"Hello, World!\") else print(\"x is less than or equal to 10\") end ''' # Chamada da fun\u00e7\u00e3o de tokeniza\u00e7\u00e3o tokens = tokenize(code) # Impress\u00e3o dos tokens gerados for token in tokens: print(token) Neste exemplo, utilizamos express\u00f5es regulares para definir os padr\u00f5es de cada tipo de token. Em seguida, compilamos essas express\u00f5es regulares em um \u00fanico padr\u00e3o usando o m\u00f3dulo re do Python. A fun\u00e7\u00e3o tokenize recebe o c\u00f3digo-fonte como entrada e itera sobre as correspond\u00eancias encontradas pelo padr\u00e3o de express\u00e3o regular. Para cada correspond\u00eancia, extra\u00edmos o tipo de token e seu valor. Ignoramos os tokens do tipo SKIP , que representam espa\u00e7os em branco e tabula\u00e7\u00f5es. Por fim, imprimimos os tokens gerados, que ser\u00e3o semelhantes a: ('KEYWORD', 'if') ('IDENTIFIER', 'x') ('OPERATOR', '>') ('NUMBER', '10') ('KEYWORD', 'then') ('KEYWORD', 'print') ('LPAREN', '(') ('STRING', '\"Hello, World!\"') ('RPAREN', ')') ('KEYWORD', 'else') ('KEYWORD', 'print') ('LPAREN', '(') ('STRING', '\"x is less than or equal to 10\"') ('RPAREN', ')') ('KEYWORD', 'end') Cada token \u00e9 representado por uma tupla contendo o tipo de token e seu valor correspondente.","title":"Implementa\u00e7\u00e3o do Analisador L\u00e9xico em Python \ud83d\udc0d"},{"location":"aula2/#vamos-brincar-no-colab","text":"Claro! Vamos refazer o exemplo anterior e criar uma tabela de s\u00edmbolos usando o pandas no Google Colab. Aqui est\u00e1 o c\u00f3digo atualizado: import re import pandas as pd def tokenize(code): # Defini\u00e7\u00e3o das express\u00f5es regulares para cada tipo de token token_specs = [ ('KEYWORD', r'if|then|else|end|print'), ('IDENTIFIER', r'[a-zA-Z_][a-zA-Z0-9_]*'), ('NUMBER', r'\\d+(\\.\\d+)?'), ('OPERATOR', r'[><=!+\\-*/%]'), ('STRING', r'\".*?\"'), ('LPAREN', r'\\('), ('RPAREN', r'\\)'), ('NEWLINE', r'\\n'), ('SKIP', r'[ \\t]+'), ] # Compila\u00e7\u00e3o das express\u00f5es regulares token_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs) regex = re.compile(token_regex) # Gera\u00e7\u00e3o dos tokens tokens = [] for match in regex.finditer(code): token_type = match.lastgroup token_value = match.group(token_type) if token_type != 'SKIP': tokens.append((token_type, token_value)) return tokens # C\u00f3digo-fonte de exemplo code = ''' if x > 10 then print(\"Hello, World!\") else print(\"x is less than or equal to 10\") end ''' # Chamada da fun\u00e7\u00e3o de tokeniza\u00e7\u00e3o tokens = tokenize(code) # Cria\u00e7\u00e3o da tabela de s\u00edmbolos usando o pandas symbol_table = pd.DataFrame(tokens, columns=['Token Type', 'Token Value']) # Impress\u00e3o da tabela de s\u00edmbolos print(\"Tabela de S\u00edmbolos:\") print(symbol_table) Neste exemplo atualizado, utilizamos o pandas para criar uma tabela de s\u00edmbolos a partir dos tokens gerados. Ap\u00f3s chamar a fun\u00e7\u00e3o tokenize com o c\u00f3digo-fonte de exemplo, criamos um DataFrame do pandas chamado symbol_table usando os tokens como dados e especificando as colunas como \"Token Type\" e \"Token Value\". Por fim, imprimimos a tabela de s\u00edmbolos usando o m\u00e9todo print . Ao executar este c\u00f3digo no Google Colab, voc\u00ea ver\u00e1 a seguinte sa\u00edda: Tabela de S\u00edmbolos: Token Type Token Value 0 KEYWORD if 1 IDENTIFIER x 2 OPERATOR > 3 NUMBER 10 4 KEYWORD then 5 KEYWORD print 6 LPAREN ( 7 STRING \"Hello, World!\" 8 RPAREN ) 9 KEYWORD else 10 KEYWORD print 11 LPAREN ( 12 STRING \"x is less than or equal to 10\" 13 RPAREN ) 14 KEYWORD end A tabela de s\u00edmbolos exibe cada token encontrado no c\u00f3digo-fonte, juntamente com seu tipo de token correspondente.","title":"Vamos Brincar no Colab!"},{"location":"aula2/#conclusao","text":"Compila\u00e7\u00e3o e interpreta\u00e7\u00e3o s\u00e3o duas abordagens distintas para processar o c\u00f3digo-fonte e execut\u00e1-lo em um computador. Enquanto a compila\u00e7\u00e3o oferece maior velocidade de execu\u00e7\u00e3o e menor consumo de recursos, a interpreta\u00e7\u00e3o proporciona maior flexibilidade e portabilidade. A escolha entre essas abordagens depende dos requisitos espec\u00edficos do projeto, levando em considera\u00e7\u00e3o fatores como desempenho, consumo de energia e facilidade de desenvolvimento. Ao compreender as diferen\u00e7as entre compila\u00e7\u00e3o e interpreta\u00e7\u00e3o, os programadores podem tomar decis\u00f5es informadas sobre qual abordagem adotar para seus projetos, buscando o equil\u00edbrio ideal entre efici\u00eancia e produtividade. \ud83d\ude80","title":"Conclus\u00e3o \ud83c\udf89"},{"location":"aula2/#indicacao-de-livros","text":"Link: Programa\u00e7\u00e3o Funcional e Concorrente em Rust Link: ASP.NET Core MVC","title":"Indica\u00e7\u00e3o de Livros:"},{"location":"aula3/","text":"Aula 3","title":"Aula 3"},{"location":"aula3/#aula-3","text":"","title":"Aula 3"},{"location":"aula4/","text":"Aula 4","title":"Aula 4"},{"location":"aula4/#aula-4","text":"","title":"Aula 4"}]}